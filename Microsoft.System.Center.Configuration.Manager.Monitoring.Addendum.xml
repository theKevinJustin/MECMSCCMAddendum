<?xml version="1.0" encoding="utf-8"?><ManagementPack ContentReadable="true" SchemaVersion="2.0" OriginalSchemaVersion="1.1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <Manifest>
    <Identity>
      <ID>Microsoft.System.Center.Configuration.Manager.Monitoring.Addendum</ID>
      <Version>1.0.2.9</Version>
    </Identity>
    <Name>Microsoft System Center 2012 Configuration Manager Monitoring Addendum</Name>
    <References>
      <Reference Alias="Health">
        <ID>System.Health.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MSCCM12D">
        <ID>Microsoft.SystemCenter2012.ConfigurationManager.Discovery</ID>
        <Version>5.0.8239.1010</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MSCCM12L">
        <ID>Microsoft.SystemCenter2012.ConfigurationManager.Library</ID>
        <Version>5.0.8239.1010</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MSCCM12M">
        <ID>Microsoft.SystemCenter2012.ConfigurationManager.Monitoring</ID>
        <Version>5.0.8239.1010</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MSIGL">
        <ID>Microsoft.SystemCenter.InstanceGroup.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWIIS2">
        <ID>Microsoft.Windows.InternetInformationServices.2012</ID>
        <Version>7.0.10249.1</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWIIS6">
        <ID>Microsoft.Windows.InternetInformationServices.2016</ID>
        <Version>10.0.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWS2M">
        <ID>Microsoft.Windows.Server.2012.Monitoring</ID>
        <Version>6.0.7323.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWS6D">
        <ID>Microsoft.Windows.Server.2016.Discovery</ID>
        <Version>10.0.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWSL">
        <ID>Microsoft.Windows.Server.Library</ID>
        <Version>10.0.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWS2R2D">
        <ID>Microsoft.Windows.Server.2012.R2.Discovery</ID>
        <Version>6.0.7323.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SC">
        <ID>Microsoft.SystemCenter.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="System">
        <ID>System.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Windows">
        <ID>Microsoft.Windows.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
    </References>
  </Manifest>
  <TypeDefinitions>
    <EntityTypes>
      <ClassTypes>
        <ClassType ID="Proactive.MECM.SCCM.ConfigMgr.Subscription.Components.Group" Accessibility="Public" Abstract="false" Base="MSIGL!Microsoft.SystemCenter.InstanceGroup" Hosted="false" Singleton="true" Extension="false" />
        <ClassType ID="Proactive.MECM.LogicalDisk.H.500GB.Group" Accessibility="Public" Abstract="false" Base="MSIGL!Microsoft.SystemCenter.InstanceGroup" Hosted="false" Singleton="true" Extension="false" />
        <ClassType ID="Proactive.MECM.SCCM.ConfigMgr.Windows.Servers.Group" Accessibility="Public" Abstract="false" Base="MSIGL!Microsoft.SystemCenter.InstanceGroup" Hosted="false" Singleton="true" Extension="false" />
        <ClassType ID="Proactive.Microsoft.SystemCenter.Configuration.Manager.Group" Accessibility="Public" Abstract="false" Base="MSIGL!Microsoft.SystemCenter.InstanceGroup" Hosted="false" Singleton="true" Extension="false" />
      </ClassTypes>
    </EntityTypes>
    <ModuleTypes>
      <DataSourceModuleType ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.Datasource" Accessibility="Internal" Batching="false">
        <Configuration>
		  <xsd:element minOccurs="1" type="xsd:string" name="DriveLetter" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
		  <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
		  <OverrideableParameter ID="DriveLetter" Selector="$Config/DriveLetter$" ParameterType="string" />
		  <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
				<Scheduler>
				  <WeeklySchedule>
					<Windows>
					  <Daily>
                        <Start>08:50</Start>
                        <End>09:00</End>
                        <DaysOfWeekMask>1</DaysOfWeekMask>
                      </Daily>
					</Windows>
				  </WeeklySchedule>
				  <ExcludeDates />
				</Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.Datasource.v1029.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  SCCM MECM Client cache cleanup and C: drive cleanup
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================
# param([string]$DriveLetter #,[string]$ComputerName)
param([string]$DriveLetter)


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ComputerName = "computername.domain.com"
$ComputerName = $env:ComputerName
#$DriveLetter = "C"
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
$ScriptName = "Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.Datasource.v1029.ps1"
$EventID = "680"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
# Load PropertyBag function 
$bag = $momapi.CreatePropertyBag()

#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# Begin MAIN script section
#=================================================================================
#Log script parameters we received
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script parameters passed into datasource: `nDriveLetter: ($DriveLetter). `nComputerName: ($ComputerName).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alert report for date ($date).")

$DSMessage = "Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for date ($date)."


# Check Disk free space
#=====================
$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -eq "C:" }
$CFreeSpace.DeviceID
 
    $DiskFreeSpace = [pscustomobject]@{
	DeviceID = $CFreeSpace.DeviceID
	Size = [math]::Round($CFreeSpace.Size/1GB,2)
	FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }
 
$DiskFreeSpace
 
$SoftwareDistribution = (gci C:\windows\SoftwareDistribution | measure length -s).sum / 1Mb
# Debug
$SoftwareDistribution 
 

# Check disk space (default C:)
#======================================= 
If ($DiskFreeSpace.FreeSpace -gt 15 )
	{
	$strCondition = "Good"
	$end
	}

If ($DiskFreeSpace.FreeSpace -lt 15 )
	{
	#Set the condition = bad.  This represents your script finding something wrong
	$strCondition = "Bad"

	# MECM SCCM Client Cleanup
	$resman= New-Object -ComObject "UIResource.UIResourceMgr"
	$cacheInfo=$resman.GetCacheInfo()
	$cacheinfo.GetCacheElements()  | foreach {$cacheInfo.DeleteCacheElement($_.CacheElementID)}

	# get-volume
	#=====================
	# $DriveLetter = "C"
	$ExpandC = get-volume
	$ExpandAction = $ExpandC | ? { ( $_.SizeRemaining -gt "0" ) -AND ( $_.Driveletter -eq "$DriveLetter" ) }

	if ( $ExpandAction.DriveLetter -eq $true)
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Expand drive via Disk Manager on ($ComputerName)")
		}

	# Cleanup C:\Windows\Temp
	#=====================
	# May see access denied errors - Get-ChildItem
	Get-ChildItem C:\Windows\Temp\ -Recurse | Remove-Item -Recurse -Force

	$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse | Measure-Object -Property Length -Sum ).sum


	# Check Disk free space AFTER cleanup
	#==================================
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID
 
	$DiskFreeSpace = [pscustomobject]@{
		DeviceID = $CFreeSpace.DeviceID
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
        }
 
	$DiskFreeSpace
 
	$DriveLetter = $CFreeSpace.DeviceID
 
 
	# Check for large profile sizes
	#==================================
	$Profiles=Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") -and ($_.localpath -notlike "C:\WINDOWS*"))}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }
	#$Profiles=Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") )}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }

	$ProfileTableObject = @()
 
	# Loop through profiles
	#foreach ($Profile in $Profiles)
		#{
		#$Profile
		#$Size = (gci $DriveLetter\users\$Profile -recurse| measure length -s).sum
		$Size = (gci $DriveLetter\users -recurse| measure length -s).sum
	 
		$ProfileTableObject += [pscustomobject]@{
		#AccountID = $Profile
		UserDirectory = "C:\Users"
		SizeGB = [math]::Round($Size/1GB,2)
	      }
	#}
	$ProfileTableObject
 
 
	# Check C Drive folder size
	#==========================
	#$CheckCDriveFolders = (gci C:\).Name | ? { ( $_ -ne "Users" ) -AND ( $_ -ne "Windows" )  }
	$CheckCDriveFolders = (gci $DriveLetter\).Name | ? { ( $_ -ne "Users" ) }
	$CheckCDriveFolders
 
	$Cfolders = @()
 
	Foreach ( $folder in $CheckCDriveFolders )
		{
		#$folder
		$Size = (Get-ChildItem "$DriveLetter\$folder" -Recurse | Measure-Object -Property Length -Sum ).sum
		#$Size
		$CFolders += [pscustomobject]@{
			Directory = $folder
			SizeGB = [math]::Round($Size/1GB,2)
			}
		}
	$Cfolders
	}


# Second attempt will clean up software distribution
#==================================
If ($DiskFreeSpace.FreeSpace -lt 15 )
	{
	# Audit Software Distribution
	#==================================
	If ( $SoftwareDistribution -lt "3000" )
		{
		Write-host "NO MECM\SCCM Action required"
		}

	If ( $SoftwareDistribution -gt "3000" )
		{
		Write-host "MECM\SCCM Action required, stopping Windows Update service, removing SoftwareDIstribution folder and restarting"
		Get-Service -Name wuauserv | Stop-Service 
		Remove-Item -Path C:\Windows\SoftwareDistribution -Recurse 
		Get-Service -Name wuauserv | Start-Service
		Write-host "Windows Update wuauserv service restarted after SoftwareDistribution directory removed"
		}


	# Summary Report
	#==================================
	$ProfileTableOutput = $ProfileTableObject | sort -property SizeGB -desc | out-string
	$CFolderOutput = $Cfolders | sort -property SizeGB -desc | out-string
 
	$SCCMClientCacheReport = @()
 
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += $DSMessage
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "MECM/SCCM Client Cache cleaned on server"
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "#===================================="
	$SCCMClientCacheReport += "# Drive audit of server for $date"
	$SCCMClientCacheReport += $DiskFreeSpace
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "# Software Distribution folder size"
	$SCCMClientCacheReport += $SoftwareDistribution
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "# Audit of profiles for cleanup"
	$SCCMClientCacheReport += $ProfileTableOutput
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "# Audit of folder size"
	$SCCMClientCacheReport += $CFolderOutput
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "NOTE: Manual effort required:"
	$SCCMClientCacheReport += "SysAdmin/Server SME required to clean up drive folders"
	$SCCMClientCacheReport += "#===================================="
	$SCCMClientCacheReport += ""
	}

$SCCMClientCacheReport

$SCCMClientCacheReport = $SCCMClientCacheReport | out-string



#Check the value of $strCondition
IF ($strCondition -eq "Good")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"NO MECM SCCM Team action required")
	$bag.AddValue('Result',$strCondition)
	}
IF ($strCondition -eq "Bad")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$SCCMClientCacheReport")
	$bag.AddValue('Result',$strCondition)
	$bag.AddValue('Summary',$SCCMClientCacheReport)
	}

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>DriveLetter</Name>
                    <Value>$Config/DriveLetter$</Value>									
                  </Parameter>				  
                </Parameters>				
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Reports.Datasource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>06:02</Start>
                        <End>06:22</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Reports.Datasource.v1029.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather MECM cache cleanup alerts for team daily report
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Reports.Datasource.v1029.ps1"
$EventID = "681"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive MECM Client Cache Cleanup Alerts for date ($date).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-1)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}


# Gather MECM alerts
# Monitors then rules
$MECMClientCacheAlerts = get-scomalert | ? { ( $_.Name -like "Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for date*" ) `
	-OR ( $_.Name -like "Expand drive via Disk Manager on*" ) `
	}  | ? { ( $_.TimeRaised -ge $Time ) }


#$MECMReportAlerts
#$MECMClientCacheAlerts.Count

# Open MECM server alerts
$MECMOpenAlerts = $MECMClientCacheAlerts	| ? { ( $_.ResolutionState -ne "255" ) }
#$MECMOpenAlerts.Count

# Closed MECM server alerts
$MECMClosedAlerts = $MECMClientCacheAlerts | ? { ( $_.ResolutionState -eq "255" ) }
#$MECMClosedAlerts.Count


# Client Cache cleanup alerts
$MECMCacheCleanupAlerts = $MECMClientCacheAlerts | ? { ( $_.Name -like "Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for date*" ) }
#$MECMCacheCleanupAlerts.Count

# Open alerts
$OpenMECMCacheCleanupAlerts = $MECMCacheCleanupAlerts | ? { ( $_.ResolutionState -ne "255" ) }
#$OpenMECMCacheCleanupAlerts.Count

# Closed alerts
$ClosedMECMCacheCleanupAlerts = $MECMCacheCleanupAlerts | ? { ( $_.ResolutionState -eq "255" ) }
#$ClosedMECMCacheCleanupAlerts.Count


# Expand drives via disk manager server alerts
$MECMExpandDriveAlerts = $MECMClientCacheAlerts | ? { ( $_.Name -like "Expand drive via Disk Manager on*" ) }
#$MECMExpandDriveAlerts.Count

# Open MECM server alerts
$OpenMECMExpandDriveAlerts = $MECMExpandDriveAlerts	| ? { ( $_.ResolutionState -ne "255" ) }
#$OpenMECMExpandDriveAlerts.Count

# Closed MECM server alerts
$ClosedMECMExpandDriveAlerts = $MECMExpandDriveAlerts | ? { ( $_.ResolutionState -eq "255" ) }
#$ClosedMECMExpandDriveAlerts.Count


# Build report
$MECMTeamReport = @()


# Check for alerts 
if ( $MECMClientCacheAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for Proactive MECM Client Cache Cleanup Alerts for ($date)"
	$MECMTeamReport += "ZERO alerts for Proactive MECM Client Cache Cleanup Alerts for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $MECMClientCacheAlerts.Count -gt 0 )
	{
	#
	# Create table output

	#
	# Show MECM alerts by Time Raised,NetBiosComputerName,Message
	#
	$MECMTeamReport += ""
	$MECMTeamReport += "# Proactive MECM Client Cache Cleanup Alerts for $($date)"
	$MECMTeamReport += "#"
	$MECMTeamReport += "#"
	$MECMTeamReport += "# NEW Alerts since last run = $($MECMClientCacheAlerts.Count)"
	$MECMTeamReport += ""
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += "# Open MECM Client Cache alerts = $($OpenMECMCacheCleanupAlerts.Count)"
	$MECMTeamReport += "# Open MECM Client Cache alerts = $($OpenMECMExpandDriveAlerts.Count)"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += ""
	$MECMTeamReport += ""
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += "# CLOSED MECM Client Cache alerts = $($ClosedMECMCacheCleanupAlerts.Count)"
	$MECMTeamReport += "# CLOSED MECM Expand Drive alerts = $($ClosedMECMExpandDriveAlerts.Count)"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += ""

	# Add logic for alert detail

	$MECMTeamReport += ""
	$MECMTeamReport += "# OPEN Alert details"
	$MECMTeamReport += "#==============================="
	$MECMTeamReport += ""

 	if ( $OpenMECMCacheCleanupAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO Open MECM Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for ($date)."
		$MECMTeamReport += ""
		}
		
	if ( $OpenMECMCacheCleanupAlerts.Count -gt 0 )
		{
		$MECMTeamReport += "#"
		$MECMTeamReport += "# Open MECM SCCM ConfigMgr Client Cache Cleanup Alert details"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $OpenMECMCacheCleanupAlerts | out-string
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += ""
		}


 	if ( $OpenMECMExpandDriveAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO Open MECM Proactive Expand drive via Disk Manager Alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenMECMExpandDriveAlerts.Count -gt 0 )
		{
		$MECMTeamReport += "#"
		$MECMTeamReport += "# Open Expand drive via Disk Manager Alert details"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $OpenMECMExpandDriveAlerts | out-string
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += ""
		}

	$MECMTeamReport += ""
	$MECMTeamReport += "# CLOSED Alert details"
	$MECMTeamReport += "#==============================="
	$MECMTeamReport += ""

 	if ( $ClosedMECMCacheCleanupAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO Closed MECM Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for ($date)."
		$MECMTeamReport += ""
		}
		
	if ( $ClosedMECMCacheCleanupAlerts.Count -gt 0 )
		{
		$MECMTeamReport += "#"
		$MECMTeamReport += "# Closed MECM SCCM ConfigMgr Client Cache Cleanup Alert details"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $ClosedMECMCacheCleanupAlerts | out-string
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += ""
		}


 	if ( $ClosedMECMExpandDriveAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO Closed MECM Proactive Expand drive via Disk Manager Alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenMECMExpandDriveAlerts.Count -gt 0 )
		{
		$MECMTeamReport += "#"
		$MECMTeamReport += "# Closed Expand drive via Disk Manager Alert details"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $ClosedMECMExpandDriveAlerts | out-string
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += ""
		}
	}

#$MECMTeamReport

$MECMTeamReport = $MECMTeamReport | out-string

#============================================================

$Result = "GOOD"
$Message = "Proactive MECM Client Cache Cleanup Alerts for ($date)"
$MECMTeamReport
$momapi.LogScriptEvent($ScriptName,$EventID,0,"$MECMTeamReport")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$MECMTeamReport)


# Return all bags
$bag

$ReportTime = Get-Date
$ScriptTime = ($ReportTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"MECM Cache Cleanup Report Completed. `n Script Runtime: ($ScriptTime) seconds.")


#
# If Cleanup needed, array of report monitors

$momapi.LogScriptEvent($ScriptName,$EventID,0,"MECM Client Cache monitor cleanup for ($date).")

$MECMReportMonitorsToClose = @()

$MECMReportMonitorsToClose += "Proactive MECM SCCM ConfigMgr Client Cache Cleanup Monitor"


# Reset open monitors
if ( $MECMOpenAlerts.Count -gt 0 )
	{
	foreach ( $MonitorDisplayName in $MECMReportMonitorsToClose )
		{
		$Monitors = @(Get-SCOMMonitor -displayname $MonitorDisplayName)

		# Set up monitor objects to reset
		foreach ($Monitor in $Monitors)
			{
			$MonitorClass = Get-SCOMClass -Id $Monitor.Target.Id
			$ActiveMonitors = Get-SCOMClassInstance -Class $MonitorClass | ? { ($_.healthstate -ne 'Success') -AND ( $_.healthstate -ne 'Uninitialized') -AND ($_.IsAvailable -eq $true) }
			# Debug
			$ActiveMonitors.Count
			# $ActiveMonitors | fl -property *
			#write-host "Found" + $ActiveMonitors.Count + "active monitors of " $Monitor
			foreach ( $UnhealthyOLDMonitor in $ActiveMonitors )
				{
				#if ( $UnhealthyOLDMonitor.AvailabilityLastModified -lt $Age )
				if ( $UnhealthyOLDMonitor.StateLastModified -lt $Age )
					{
					#$UnhealthyMonitors += $ActiveMonitors.Count
					#UnhealthyOLDMonitor | select AvailabilityLastModified,Path,DisplayName
					#$UnhealthyOLDMonitor.Count
					#write-host "Found" + $UnhealthyOLDMonitor.Count + "unhealthy monitor beyond" $Age "days."
					#write-host ""
					if ( $ActiveMonitors.Count -gt 0)
						{
						foreach ( $ActiveMonitor in $UnhealthyOLDMonitor )
							{
							# Debug
							$ActiveMonitor.ID
							write-host " Resetting Health State on '" + $ActiveMonitor.FullName + "'" 
							write-host ""
							$ActiveMonitor.ResetMonitoringState($ActiveMonitor)
							}
						}
					}
				}
			}
		}
	}

$momapi.LogScriptEvent($ScriptName,$EventID,0,"MECM Client Cache monitor cleanup for ($date).")

#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.MECM.SCCM.Configuration.Manager.Reports.Datasource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>06:00</Start>
                        <End>06:20</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.MECM.SCCM.Configuration.Manager.Reports.Datasource.v1029.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather MECM alerts for team daily report
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.MECM.SCCM.Configuration.Manager.Reports.Datasource.v1029.ps1"
$EventID = "681"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"


# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather MECM Alerts for date ($date).")


# Gather MECM alerts
# Monitors then rules
$MECMReportAlerts = get-scomalert -ResolutionState (0..254) | ? { ( $_.Name -eq "Available Megabytes of Memory is too low" ) `
	-OR ( $_.Name -eq "Action Account Not Configured Correctly" ) `
	-OR ( $_.Name -like "Asset Intelligence*" ) `
	-OR ( $_.Name -eq "Certificate lifespan alert" ) `
	-OR ( $_.Name -eq "Component stopped alert" ) `
	-OR ( $_.Name -eq "Content distribution alert" ) `
	-OR ( $_.Name -like "DFS-R: *" ) `
	-OR ( $_.Name -like "DHCP*" ) `
	-OR ( $_.Name -eq "DHCP Service Stopped" ) `
	-OR ( $_.Name -eq "Distribution fails to access network alert" ) `
	-OR ( $_.Name -eq "DNS Client Service Stopped" ) `
	-OR ( $_.Name -eq "Event log is full" ) `
	-OR ( $_.Name -eq "Fail to access site system alert" ) `
	-OR ( $_.Name -eq "Fail to read Active Directory alert" ) `
	-OR ( $_.Name -eq "Fail to update Active Directory alert" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Failed to install application on client" ) `
	-OR ( $_.Name -eq "File Dispatch Manager Not Connecting to Site Server" ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -eq "Logical disk current queue length is too high" ) `
	-OR ( $_.Name -eq "Logical Disk Free Space is low" ) `
	-OR ( $_.Name -like "Logical disk transfer*" ) `
	-OR ( $_.Name -eq "Maintenance task failure alert" ) `
	-OR ( $_.Name -like "Management point*" ) `
	-OR ( $_.Name -eq "Max Concurrent API Reached alert" ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -eq "Microsoft Windows Server AD PasswordCheck Script Alert Rule" ) `
	-OR ( $_.Name -like "MSSQL*" ) `
	-OR ( $_.Name -eq "NTFS reported the logical disk is in error or corrupt." ) `
	-OR ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -like "PROACTIVE -*" ) `
	-OR ( $_.Name -eq "Run As Account Could Not Log On" ) `
	-OR ( $_.Name -like "Site Component*" ) `
	-OR ( $_.Name -eq "Site Roles" ) `
	-OR ( $_.Name -like "Site Server*" ) `
	-OR ( $_.Name -eq "SMSExec CPU Usage is Too High" ) `
	-OR ( $_.Name -eq "Software Update Point Not Available" ) `
	-OR ( $_.Name -eq "SQL Server Port Not Correct." ) `
	-OR ( $_.Name -eq "State Migration Point Not Available" ) `
	-OR ( $_.Name -eq "System Center Management Health Service Unloaded System Rule(s)") `
	-OR ( $_.Name -eq "System Center Management Health Service Unable to Process New Configuration" ) `
	-OR ( $_.Name -eq "System summary task failure alert" ) `
	-OR ( $_.Name -eq "TCP/IP NetBIOS Service Stopped" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "Windows Event Log Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Firewall Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Remote Management Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Server Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "WSUS Synchronization Failed" ) `
	}  | ? { ( $_.TimeRaised -ge $Time ) }


#$MECMReportAlerts
#$MECMReportAlerts.Count


# Break out alerts into MECM servers
$MECMServerAlerts = @()

$MECMServerAlerts = $MECMReportAlerts | ? { ( $_.NetBiosComputerName -like "*##MECMServerRegEX##*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*##MECMServerRegEX##*" ) `
	}

#$MECMServerAlerts.Count

# Open MECM server alerts
$MECMOpenAlerts = $MECMServerAlerts	| ? { ( $_.ResolutionState -ne "255" ) }
#$MECMOpenAlerts.Count

# Open MECM server alerts since last report
$MECMAlertsSinceReport = $MECMServerAlerts | ? { ( $_.TimeRaised -ge $Time ) }
#$MECMAlertsSinceReport.Count

# Closed MECM server alerts
$MECMClosedAlerts = get-scomalert -ResolutionState 255 | ? { ( $_.Name -eq "Available Megabytes of Memory is too low" ) `
	-OR ( $_.Name -eq "Action Account Not Configured Correctly" ) `
	-OR ( $_.Name -like "Asset Intelligence*" ) `
	-OR ( $_.Name -eq "Certificate lifespan alert" ) `
	-OR ( $_.Name -eq "Component stopped alert" ) `
	-OR ( $_.Name -eq "Content distribution alert" ) `
	-OR ( $_.Name -like "DFS-R: *" ) `
	-OR ( $_.Name -like "DHCP*" ) `
	-OR ( $_.Name -eq "DHCP Service Stopped" ) `
	-OR ( $_.Name -eq "Distribution fails to access network alert" ) `
	-OR ( $_.Name -eq "DNS Client Service Stopped" ) `
	-OR ( $_.Name -eq "Event log is full" ) `
	-OR ( $_.Name -eq "Fail to access site system alert" ) `
	-OR ( $_.Name -eq "Fail to read Active Directory alert" ) `
	-OR ( $_.Name -eq "Fail to update Active Directory alert" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Failed to install application on client" ) `
	-OR ( $_.Name -eq "File Dispatch Manager Not Connecting to Site Server" ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -eq "Logical disk current queue length is too high" ) `
	-OR ( $_.Name -eq "Logical Disk Free Space is low" ) `
	-OR ( $_.Name -like "Logical disk transfer*" ) `
	-OR ( $_.Name -eq "Maintenance task failure alert" ) `
	-OR ( $_.Name -like "Management point*" ) `
	-OR ( $_.Name -eq "Max Concurrent API Reached alert" ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -eq "Microsoft Windows Server AD PasswordCheck Script Alert Rule" ) `
	-OR ( $_.Name -like "MSSQL*" ) `
	-OR ( $_.Name -eq "NTFS reported the logical disk is in error or corrupt." ) `
	-OR ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -like "PROACTIVE -*" ) `
	-OR ( $_.Name -eq "Run As Account Could Not Log On" ) `
	-OR ( $_.Name -like "Site Component*" ) `
	-OR ( $_.Name -eq "Site Roles" ) `
	-OR ( $_.Name -like "Site Server*" ) `
	-OR ( $_.Name -eq "SMSExec CPU Usage is Too High" ) `
	-OR ( $_.Name -eq "Software Update Point Not Available" ) `
	-OR ( $_.Name -eq "SQL Server Port Not Correct." ) `
	-OR ( $_.Name -eq "State Migration Point Not Available" ) `
	-OR ( $_.Name -eq "System Center Management Health Service Unloaded System Rule(s)") `
	-OR ( $_.Name -eq "System Center Management Health Service Unable to Process New Configuration" ) `
	-OR ( $_.Name -eq "System summary task failure alert" ) `
	-OR ( $_.Name -eq "TCP/IP NetBIOS Service Stopped" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "Windows Event Log Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Firewall Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Remote Management Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Server Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "WSUS Synchronization Failed" ) `
	}
#$MECMClosedAlerts.Count


#
# MECM Specific config alerts
$MECMAppAlerts = $MECMServerAlerts | ? { ( $_.Name -eq "Component stopped alert" ) `
	-OR ( $_.Name -eq "Content distribution alert" ) `
	-OR ( $_.Name -eq "Distribution fails to access network alert" ) `
	-OR ( $_.Name -eq "Fail to read Active Directory alert" ) `
	-OR ( $_.Name -eq "Fail to update Active Directory alert" ) `
	-OR ( $_.Name -eq "File Dispatch Manager Not Connecting to Site Server" ) `
	-OR ( $_.Name -eq "Maintenance task failure alert" ) `
	-OR ( $_.Name -like "Management point*" ) `
	-OR ( $_.Name -eq "MSSQL on Windows: Filegroup is running out of space" ) `
	-OR ( $_.Name -eq "MSSQL on Windows: Database ROWS Data is Out of Space" ) `
	-OR ( $_.Name -like "Site server*" ) `
	-OR ( $_.Name -eq "SQL Server Port Not Correct." ) `
	-OR ( $_.Name -eq "WSUS Synchronization Failed" ) `
	}
	# | ? { $_.TimeRaised -gt $Time }

#$MECMAppAlerts.Count

$OpenMECMAppAlerts = $MECMAppAlerts
#$OpenMECMAppAlerts.Count

$ClosedMECMAppAlerts = $MECMClosedAlerts | ? { ( $_.Name -eq "Component stopped alert" ) `
	-OR ( $_.Name -eq "Content distribution alert" ) `
	-OR ( $_.Name -eq "Distribution fails to access network alert" ) `
	-OR ( $_.Name -eq "Fail to read Active Directory alert" ) `
	-OR ( $_.Name -eq "Fail to update Active Directory alert" ) `
	-OR ( $_.Name -eq "File Dispatch Manager Not Connecting to Site Server" ) `
	-OR ( $_.Name -eq "Maintenance task failure alert" ) `
	-OR ( $_.Name -like "Management point*" ) `
	-OR ( $_.Name -eq "MSSQL on Windows: Filegroup is running out of space" ) `
	-OR ( $_.Name -eq "MSSQL on Windows: Database ROWS Data is Out of Space" ) `
	-OR ( $_.Name -like "Site server*" ) `
	-OR ( $_.Name -eq "SQL Server Port Not Correct." ) `
	-OR ( $_.Name -eq "WSUS Synchronization Failed" ) `
	}
#$ClosedMECMAppAlerts.Count




#
# Additional insights
#
# PROACTIVE - Server restart pending detected
$PendingRestart = $MECMServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) `
	}
	#| ? { $_.TimeRaised -gt $Time }

#$PendingRestart.Count
$PendingRestart = $PendingRestart | ft NetbiosComputerName,TimeRaised -auto -wrap

$OpenPendingRestart = $PendingRestart
#$OpenPendingRestart.Count

$ClosedPendingRestart = $MECMClosedAlerts | ? { ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) }
#$ClosedPendingRestart.Count


#
# PROACTIVE - Server NOT rebooted in past month
$NotRebooted = $MECMServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) `
	} | ? { $_.TimeRaised -gt $Time }

#$NotRebooted.Count
$NotRebooted = $NotRebooted | ft NetbiosComputerName,TimeRaised -auto -wrap

$OpenNotRebooted = $NotRebooted
#$OpenNotRebooted.Count

$ClosedNotRebooted = $MECMClosedAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) }
#$ClosedNotRebooted.Count


#
# PROACTIVE - Server NOT patched in past month
$NotPatched = $MECMServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) `
	} | ? { $_.TimeRaised -gt $Time }

#$NotPatched.Count
$NotPatched = $NotPatched | ft NetbiosComputerName,TimeRaised -auto -wrap

$OpenNotPatched = $NotPatched
#$OpenNotPatched.Count

$ClosedNotPatched = $MECMClosedAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) }
#$ClosedNotPatched.Count


#
# Failed to install application on client
$FailedAppInstall = $MECMReportAlerts | ? { ( $_.Name -eq "Failed to install application on client" ) `
	} | ? { $_.TimeRaised -gt $Time }
	
#$FailedAppInstall.Count


#
# High CPU Memory alerts
$HighAlerts = $MECMServerAlerts | ? { ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) `
	-OR ( $_.Name -eq "SMSExec CPU Usage is Too High" ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -like "Logical disk transfer*" ) `
	} | ? { $_.TimeRaised -gt $Time }

#$HighAlerts.Count
#$HighAlerts = $HighAlerts | ft NetBiosComputerName,TimeRaised,Name -auto

$OpenHighAlerts = $HighAlerts
#$OpenHighAlerts.Count

$ClosedHighAlerts = $MECMClosedAlerts | ? { ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) `
	-OR ( $_.Name -eq "SMSExec CPU Usage is Too High" ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -like "Logical disk transfer*" ) `
	}
#$ClosedHighAlerts.Count


#
# Action Account alerts
$ActionAccountAlerts = $MECMServerAlerts | ? { ( $_.Name -eq "Action Account Not Configured Correctly" ) `
	-OR ( $_.Name -eq "Run As Account Could Not Log On" ) `
	} | ? { $_.TimeRaised -gt $Time }

#$ActionAccountAlerts.Count

$OpenActionAccountAlerts = $ActionAccountAlerts
#$OpenActionAccountAlerts.Count

$ClosedActionAccountAlerts = $MECMClosedAlerts | ? { ( $_.Name -eq  "Action Account Not Configured Correctly" ) `
	-OR ( $_.Name -eq "Run As Account Could Not Log On" ) `
	}
#$ClosedActionAccountAlerts.Count

#
# Test totals of alerts
$Test = $MECMServerAlerts.count + $FailedAppInstall.Count
#$Test



# 
# Unhealthy/Maintenance mode agents
#
# Gather Details section
# $Details = get-scomagent | ? { $_.HealthState -ne "Success" } |ft DisplayName| out-string
#$Details

$Class = (get-scomclass -Name "Microsoft.Windows.Computer" )
$instance = ( $Class | ? { $_.Name -like "Microsoft.Windows.Computer" }  |Get-SCOMClassInstance )
  
 $MM = ($Instance | ? { $_.InMaintenanceMode -eq "True" }).DisplayName `
	| ? { ( $_.DisplayName -like "*##MECMServerRegEX##*" ) `
	}
	#write-host "MM Maintenance mode Agents `n" ; $Unhealthy.InputObject
    $MaintM = $MM | sort | out-string


#  $UnHealthyAgents = ( get-scomagent | ? { $_.HealthState -ne "Success" } ).DisplayName `
$UnHealthyAgents = ( get-scomagent | ? { $_.HealthState -ne "Success" } ).DisplayName `
	| ? { ( $_.DisplayName -like "*##MECMServerRegEX##*" ) `
	}

if ( $MM.Count -gt 0 )
	{
	$CompareMM = compare-object -ReferenceObject $MM -DifferenceObject $UnhealthyAgents
	}


  #foreach ( $server in $UnHealthyAgents )
	#{
	#if ( ! $($MaintM | select-string $server) -eq $True )
		#{
		#write-host $server "is in Maintenance"
		#$Unhealthy += "$server"
		#}
	#}

  #$Unhealthy
  #$Details = $Unhealthy.InputObject


#$MECMReportAlerts
#$DownAgents = get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -eq "Health Service Heartbeat Failure") `
# If you want to know alerts for all Down, don't use $MECMReportAlerts (has $Time built in)
#  $DownAgents = $MECMReportAlerts | ? { ($_.Name -eq "Health Service Heartbeat Failure") `
$DownAgents = get-SCOMAlert | ? { ($_.Name -eq "Health Service Heartbeat Failure") `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "System Center Management Health Service Unloaded System Rule(s)") `
	-OR ( $_.Name -eq "System Center Management Health Service Unable to Process New Configuration" ) `
	} | ? { ( $_.NetBiosComputerName -like "*##MECMServerRegEX##*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*##MECMServerRegEX##*" ) `
	}


#$DownAgents
#$DownAgents.count


if ( $DownAgents.Count -gt 0 )
	{
    $CompareDown = compare-object -ReferenceObject $DownAgents -DifferenceObject $UnhealthyAgents
	# Format output of DownAgents
	$Down = $DownAgents | ft MonitoringObjectDisplayName,TimeRaised,Name -autosize | out-string
	#$Down
	}


if ( $DownAgents.Count -eq 0 )
	{
	$Compare = $MM.Count + $CompareMM.Count
    $CompareDown = "ZERO NOT monitored servers as of report run"
	}


# Compare Unhealthy agents
$Unhealthy = @()

if ( $UnHealthyAgents.Count -eq 0 )
	{
	$Unhealthy += ""
	$Unhealthy += "ZERO NOT healthy agents as of report run"
	}

if ( $UnHealthyAgents.Count -gt 0 )
	{
	$Unhealthy += ""
	$Unhealthy += $UnHealthyAgents | sort | out-string
	$Unhealthy += ""
	}

$Test = $DownAgents.Count +   $UnHealthyAgents.Count
#$Test


#===============================================
#
# Logical Disk free space alerts
#===============================================

$LDSTest = $MECMReportAlerts | ? { ( $_.Name -eq "Logical disk Free space is low" ) }

if ( $LDSTest.Count -gt 0 )
	{
	#$LDSTest

	# Gather details
	$LDSSummary = $LDSTest |ft NetbiosComputerName,MonitoringObjectName,Parameters -autosize | out-string
	# Gather Details section
	$LDSDetails = $LDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string

	#$LDSSummary
	#$LDSDetails

	$OpenLDSTest = $LDSTest
	#$OpenLDSTest.Count

	if ( $OpenLDSTest.Count -gt 0 )
		{
		# Summary
		$LDSOpenSummary = $LDSTest |ft NetbiosComputerName,MonitoringObjectName,Parameters -autosize | out-string
		# Gather Details
		$LDSOpenDetails = $LDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string
		}

	$ClosedLDSTest = $MECMClosedAlerts | ? { ( $_.Name -eq "Logical disk Free space is low" ) }
	#$ClosedLDSTest.Count

	if ( $ClosedLDSTest.Count -gt 0 )
		{
		# Summary
		$LDSClosedSummary = $ClosedLDSTest |ft NetbiosComputerName,MonitoringObjectName,Parameters -autosize | out-string
		# Gather Details section
		$LDSClosedDetails = $ClosedLDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string
		}
	}


#===============================================
# Expiring certificates
# Certificates about to expire/expired
#===============================================

$Class = (get-scomclass -DisplayName "Certificate" )
$instance = ( $Class |Get-SCOMClassInstance )
$MECMPKIexpired = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	# PKI certs can have Certstore, but it's not always searchable/display capable
	#} | ? { $_.CertStore -like "Intermediate Certification*" `
	} | ? { ( $_.Path -like "*##MECMServerRegEX##*" ) `
	} # | ft Path,Values -auto -wrap  # DisplayName

#$MECMPKIexpired.count

$MECMPKIpersonal = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	} | ? { ( $_.CertStore -eq "Personal" ) `
	} | ? { ( $_.Path -like "*##MECMServerRegEX##*" ) `
	} # | ft Path,Values -auto -wrap  # DisplayName

#$MECMPKIpersonal.count

# Intermediate Cert Check
	# PKI certs can have Certstore, but it's not always searchable/display capable
	#} | ? { $_.CertStore -like "Intermediate Certification*" `

$MECMIntermediate = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	} | ? { $_.CertStore -like "Intermediate Certification*" `
	} | ? { ( $_.Path -like "*##MECMServerRegEX##*" ) `
	} # | ft Path,Values -auto -wrap  # DisplayName
	
#$MECMIntermediate.Count


$MECMRootCerts = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	} | ? { $_.CertStore -like "Root" `
	} | ? { ( $_.Path -like "*##MECMServerRegEX##*" ) `
	} # | ft Path,Values -auto -wrap  # DisplayName
	#$MECMRootCerts.Count


#
# Remaining alerts - not Proactive
$MECMRemaining = @()
$MECMRemaining = $MECMServerAlerts | ? { ( $_.Name -notlike "Proactive*" ) `
	-AND ( $_.Name -notlike "Certificate lifespan alert*" ) `
	-AND ( $_.Name -notlike "Logical disk transfer*" ) `
	-AND ( $_.Name -notlike "Logical disk Free space is low*" ) `
	-AND ( $_.Name -notlike "Management point*" ) `
	-AND ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-AND ( $_.Name -eq "MSSQL on Windows: Filegroup is running out of space" ) `
	-AND ( $_.Name -eq "MSSQL on Windows: Database ROWS Data is Out of Space" ) `
	-AND ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-AND ( $_.Name -eq "Site server HINV process backlog alert" ) `
	-AND ( $_.Name -eq "Site server HINV process backlog alert" ) `
	-AND ( $_.Name -eq "Site server auth ddm inbox backlog alert" ) `
	-AND ( $_.Name -eq "SMSExec CPU Usage is Too High" ) `
	-AND ( $_.Name -eq "SQL Server Port Not Correct." ) `
	-AND ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-AND ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-AND ( $_.Name -eq "WSUS Synchronization Failed" ) `
	}

#$MECMRemaining

$MECMRemaining = $MECMRemaining | ft NetbiosComputerName,TimeRaised,Name -auto -wrap


# Build report
$MECMTeamReport = @()


# Check for alerts 
if ( $MECMServerAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for MECM Team Daily report for ($date)"
	$MECMTeamReport += "ZERO alerts for MECM Team Daily report for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $MECMServerAlerts.Count -gt 0 )
	{
	#
	# Create table output	

	#
	# Show MECM alerts by Time Raised,NetBiosComputerName,Message
	#
	$MECMTeamReport += ""
	$MECMTeamReport += "# MECM Team Daily report for $($date)"
	$MECMTeamReport += "#"
	$MECMTeamReport += "#"
	$MECMTeamReport += "# NEW Alerts since last run = $($MECMAlertsSinceReport.Count)"
	$MECMTeamReport += ""
	$MECMTeamReport += "# Total OPEN alerts"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += "# MECM alerts = $($MECMOpenAlerts.Count)"
	$MECMTeamReport += ""
	$MECMTeamReport += "# Server performance alerts = $($OpenHighAlerts.Count)"
	$MECMTeamReport += "# Logical Disk full alerts = $($OpenLDSTest.Count)"
	$MECMTeamReport += "# MECM Application alerts = $($OpenMECMAppAlerts.Count)"
	$MECMTeamReport += "# MECM patch failures = $($FailedInstallAlerts.Count)"
	$MECMTeamReport += "# Action Account logon failures = $($OpenActionAccountAlerts.Count)"
	$MECMTeamReport += ""
	$MECMTeamReport += "# PKI expired certificate alerts = $($MECMPKIexpired.Count)"
	$MECMTeamReport += "# PKI expired personal certificate alerts = $($MECMPKIpersonal.Count)"
	$MECMTeamReport += "# PKI Intermediate certificate alerts = $($MECMIntermediate.Count)"
	$MECMTeamReport += "# PKI Root certificate alerts = $($MECMRootCerts.Count)"
	$MECMTeamReport += ""
 	$MECMTeamReport += "# Servers Pending Restart = $($OpenPendingRestart.Count)"
 	$MECMTeamReport += "# Servers servers NOT rebooted= $($OpenNotRebooted.Count)"
 	$MECMTeamReport += "# Servers NOT patched = $($OpenNotPatched.Count)"
	$MECMTeamReport += ""
 	$MECMTeamReport += "# Total remaining alerts = $($MECMRemaining.Count)"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += ""
	$MECMTeamReport += "# Monitoring Health"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += "# Servers in Maintenance mode = $($MM.Count)"
	$MECMTeamReport += "# Unhealthy Agents = $($UnHealthyAgents.Count)"
	$MECMTeamReport += "# Down agents = $(($DownAgents.MonitoringObjectDisplayName).Count)"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += ""
	$MECMTeamReport += ""
	$MECMTeamReport += "# CLOSED alerts"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += "# Server performance alerts = $($ClosedHighAlerts.Count)"
	$MECMTeamReport += "# Logical Disk full alerts = $($ClosedLDSTest.Count)"
	$MECMTeamReport += "# MECM Application alerts = $($ClosedMECMAppAlerts.Count)"
	$MECMTeamReport += "# Action Account logon failures = $($ClosedActionAccountAlerts.Count)"
	$MECMTeamReport += "#========================================================"
 	$MECMTeamReport += "# Servers Pending Restart = $($ClosedPendingRestart.Count)"
 	$MECMTeamReport += "# Servers servers NOT rebooted = $($ClosedRebooted.Count)"
 	$MECMTeamReport += "# Servers NOT patched = $($ClosedNotPatched.Count)"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += ""

	#$MECMServerAlerts = $MECMServerAlerts | ft NetbiosComputerName,TimeRaised,Name -auto -wrap
	#$MECMServerAlerts


	$MECMTeamReport += ""
	$MECMTeamReport += "# OPEN Alert details"
	$MECMTeamReport += "#==============================="
	$MECMTeamReport += ""


	# Add logic for agents monitored/down/maintenance mode
	if ( $Test -eq 0)
		{
		$MECMTeamReport += "ZERO MECM servers NOT monitored for ($date)."
		$MECMTeamReport += ""
		}
	
	if ( $Test -gt 0)
		{
		$MECMTeamReport += "# NOT monitored servers for ($date)."
		$MECMTeamReport += "#================================================"
		$MECMTeamReport += $Down
		$MECMTeamReport += ""
		
		if ( $MM.Count -eq 0)
			{
			$MECMTeamReport += "ZERO MECM servers in maintenance mode for ($date)."
			$MECMTeamReport += ""
			}

		if ( $MM.Count -gt 0)
			{
			$MECMTeamReport += ""
			$MECMTeamReport += "# Servers in Maintenance Mode MM"
			$MECMTeamReport += "#==============================="
			$MECMTeamReport += $MaintM
			$MECMTeamReport += ""
			$MECMTeamReport += ""
			}
		}


 	if ( $OpenLDSTest.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM Logical Disk free space alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenLDSTest.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# Summary of Daily Logical Disk free space alerts for ($date)"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += "#"
		$MECMTeamReport += "# Logical Disk Free Space alerts"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $LDSOpenSummary
		$MECMTeamReport += ""
		$MECMTeamReport += "# Alert details"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $LDSOpenDetails | out-string
		$MECMTeamReport += ""
		}


 	if ( $OpenMECMAppAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM Application alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenMECMAppAlerts.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# MECM Application alert detail for ($date)"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $OpenMECMAppAlerts | ft NetbiosComputerName,Parameters,Name -auto | out-string
		$MECMTeamReport += ""
		}


	if ( $OpenHighAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM Performance alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenHighAlerts.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "#  MECM Performance alert detail"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $OpenHighAlerts |ft TimeRaised,NetBiosComputerName,Description -auto -wrap | out-string
		$MECMTeamReport += ""
		}


	if ( $MECMPKIexpired.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM PKI Certificates about to expire for ($date)."
		$MECMTeamReport += ""
		}

	if ( $MECMPKIexpired.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# Certificates about to expire/expired"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $MECMPKIexpired | ft Path,Values -auto -wrap | out-string
		$MECMTeamReport += ""
		}

	if ( $MECMIntermediate.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM PKI Intermediate Certificates alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $MECMIntermediate.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# MECM Intermediate Certificate alerts = $($SharePointIntermediate.Count)"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $MECMIntermediate | ft Path,Values -auto -wrap | out-string
		$MECMTeamReport += ""
		$MECMTeamReport += "***Execute MANUAL task to disable certs!"
		$MECMTeamReport += ""
		}


	if ( $MECMRootCerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM PKI Root Certificates alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $SharePointRootCerts.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# MECM Root Certificate alerts = $($SharePointIntermediate.Count)"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $MECMRootCerts | ft Path,Values -auto -wrap | out-string
		$MECMTeamReport += ""
		$MECMTeamReport += "***Execute MANUAL task to disable certs!"
		$MECMTeamReport += ""
		}

	if ( $MECMPKIpersonal.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM PKI Personal Certificate alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $MECMPKIpersonal.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# MECM Personal Certificate alerts = $($MECMPKIpersonal.Count)"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $MECMPKIpersonal | ft Path,Values -auto -wrap | out-string
		$MECMTeamReport += ""
		$MECMTeamReport += "***Manual task to update server/application certs required"
		$MECMTeamReport += ""
		}


	if ( $MECMRemaining.count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM other MECM Operating System issues for ($date)."
		$MECMTeamReport += ""
		}

	if ( $MECMRemaining.count -gt 0 )
		{
		$MECMTeamReport += "# Other MECM application OR Operating System issues "
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += $MECMRemaining
		$MECMTeamReport += "#========================"
		$MECMTeamReport += ""
		}

	# Failed to install applications
	if ( $OpenFailedAppInstall.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM 'Failed to install' application errors for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenFailedAppInstall.Count -gt 0 )
		{
		$FailedAppInstall = $FailedAppInstall | ft NetbiosComputerName,TimeRaised,Description -auto -wrap | out-string
		$MECMTeamReport += "# MECM 'Failed to install application on client' alerts"
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += $FailedAppInstall
		$MECMTeamReport += "#========================"
		$MECMTeamReport += ""
		}

	if ( $OpenPendingRestart.count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM servers pending restart for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenPendingRestart.count -gt 0 )
		{
		$MECMTeamReport += "# MECM servers pending reboot for patches"
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += $OpenPendingRestart | ft NetbiosComputerName,TimeRaised -auto -wrap | out-string
		$MECMTeamReport += "#========================"
		$MECMTeamReport += ""
		}

	if ( $OpenNotRebooted.count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM servers NOT rebooted in past 35 days as of ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenNotRebooted.count -gt 0 )
		{
		$MECMTeamReport += "# MECM servers not rebooted (at least 35 days pass before alert)"
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += $OpenNotRebooted | ft NetbiosComputerName,TimeRaised -auto -wrap | out-string
		$MECMTeamReport += "#========================"
		$MECMTeamReport += ""
		}

	if ( $OpenNotPatched.count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM servers NOT patched in past 35 days as of ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenNotPatched.count -gt 0 )
		{
		$MECMTeamReport += "# MECM servers not patched (at least 35 days pass before alert)"
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += $OpenNotPatched | ft NetbiosComputerName,TimeRaised -auto -wrap | out-string
		$MECMTeamReport += "#============================================="
		}
	
	
	if ( $OpenActionAccountAlerts.count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM Action Account errors for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenActionAccountAlerts.count -gt 0 )
		{
		$MECMTeamReport += "# MECM Action Account alert detail"
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += "# OPEN Action Account logon failures = $($OpenActionAccountAlerts.Count)"
		$MECMTeamReport += ""
		$MECMTeamReport += "# OPEN Action Account logon failures"
		$MECMTeamReport += $OpenActionAccountAlerts | ft NetbiosComputerName,Parameters  -auto | out-string
		$MECMTeamReport += "#============================================="
		}

	$MECMTeamReport += ""
	}

#$MECMTeamReport

$MECMTeamReport = $MECMTeamReport | out-string

#============================================================

	$Result = "GOOD"
	$Message = "MECM Team Daily report for ($date)"
	$MECMTeamReport
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$MECMTeamReport")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$MECMTeamReport)


# Return all bags
$bag

$ReportTime = Get-Date
$ScriptTime = ($ReportTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")


#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.MECM.SCCM.Configuration.Manager.Cleanup.Datasource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>06:03</Start>
                        <End>06:23</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.MECM.SCCM.Configuration.Manager.Cleanup.Datasource.v1029.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather MECM alerts for team daily alert cleanup
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.MECM.SCCM.Configuration.Manager.Cleanup.Datasource.v1029.ps1"
$EventID = "681"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-1)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Cleanup MECM Alerts for date ($date).")


# Cleanup MECM alerts
#===============================================
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
$SCOMCoreMP = Get-SCOMManagementPack -DisplayName "Microsoft System Center 2012 Configuration Manager Monitoring"
$SCOMCoreRules = $SCOMCoreMP.GetRules()
$SCOMCoreMonitors = $SCOMCoreMP.GetMonitors()

$SCOMCoreReportAlerts = Get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMCoreReportAlerts.Count

$SCOMCoreRuleAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -in $SCOMCoreRules.DisplayName) }
$SCOMCoreRuleAlerts.Count

$SCOMCoreMonitorAlerts = $SCOMCoreReportAlerts | ? { ($_.Name -in $SCOMCoreMonitors.DisplayName ) }
$SCOMCoreMonitorAlerts.Count

# Open/Closed breakout
$OpenMECMAlerts = $SCOMCoreReportAlerts
$OpenMECMAlerts.Count
$ClosedMECMAlerts = Get-SCOMAlert -ResolutionState 255 | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$ClosedMECMAlerts.Count

#============================================================

  $Result = "GOOD"
  $Message = "MECM Team Daily Cleanup for ($date)"
  $DSMessage = "Proactive DailyTasks MECM Team Cleanup Script Alert Rule"


# Build report
#============================================================
$MECMTeamCleanup = @()

# Check for alerts 
if ( $SCOMCoreReportAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for MECM Team Daily Cleanup for ($date)"
	$MECMTeamCleanup += "ZERO alerts for MECM Team Daily Cleanup for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"ZERO alerts for $Message")
	}


# $MECMReportMonitorsToClose or $ActiveMonitors ?
#==================================================
if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	#
	# Create table output

	#
	# Show MECM alerts by Time Raised,NetBiosComputerName,Message
	#
	$MECMTeamCleanup += ""
	$MECMTeamCleanup += $DSMessage
	$MECMTeamCleanup += "#"
	$MECMTeamCleanup += "# MECM Team Daily Cleanup for $($date)"
	$MECMTeamCleanup += "#"
	$MECMTeamCleanup += "Reset $($ActiveMonitors.Count) unhealthy monitors"
	$MECMTeamCleanup += "#"
	}

$MECMTeamCleanup


# Log event with report
$momapi.LogScriptEvent($ScriptName,$EventID,0,"$MECMTeamCleanup")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$SCOMCoreReportAlerts.Count)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$MECMTeamCleanup)


# Return all bags
$bag

$ReportTime = Get-Date
$ScriptTime = ($ReportTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")


# Debug Write event for rule closure
#=================================================================================
# $UnhealthyMonitors = $($UnhealthyMonitors | measure-object -sum).sum
#$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive MECM monitors auto-closed on ($date).")
# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks MECM monitor reset completed for ($date)")

$SCOMCoreRulesToClear = $SCOMCoreRuleAlerts | where { ( $_.TimeAdded -lt $Age ) }
# Convert Age back to days for alert properties logging
$Days = ((Get-date) - $Age).Days
if ( $SCOMCoreRulesToClear.Count -gt 0 )
	{
	$SCOMCoreRulesToClear | Resolve-SCOMAlert -Comment "Closing $Days day old alerts after report alert generated - MECM SCCM Addendum Automation DS"
	}

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"MECM SCCM addendum automation rule reset completed for ($date)")


#=================================================================================
# Reset Monitors Script base code modified
# Put ps1 in mgmtpacks folder
# https://sc.scomurr.com/scom-2012-monitor-reset-cleaning-up-the-environment/
#	Download
# https://gallery.technet.microsoft.com/SCOM-2012-Batch-reset-63a17534
	
#Alternate
#https://gallery.technet.microsoft.com/scriptcenter/Auto-reset-script-for-d8b775ca

# Changed up logic to sort unique classes in mgmnt pack families.
# Added Age variable for monitors thanks to Aris Somatis - $Age specified in top level variables
# Cycling through monitors made reset loop huge ~650 monitors when only ~50 classes
# New logic reduced runtime from 8 minutes to roughly 8 seconds
#=================================================================================

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks MECM Monitors reset started for ($date).")


if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	# Get MECM SCCM classes
		$MECMLibrary = Get-SCOMManagementPack -name "Microsoft.SystemCenter2012.ConfigurationManager.Library"
			#get-scomclass -ManagementPack $MECMLibrary
		$MECMMonitoring = $SCOMCoreMP
			#get-scomclass -ManagementPack $MECMMonitoring | fl DisplayName,Name,ID
		$MECMDiscovery = Get-SCOMManagementPack -DisplayName "Microsoft System Center 2012 Configuration Manager Discovery"
			#get-scomclass -ManagementPack $MECMDiscovery | fl DisplayName,Name,ID

	# MECM pack naming
	$MECMClasses = @(Get-SCOMClass -ManagementPack $MECMLibrary; Get-SCOMClass -ManagementPack $MECMDiscovery; )
	$MECMClass = $MECMClasses | sort -property Name -uniq
	# Debug
	$MECMClass.Count

	# Set up monitor objects to reset
	foreach ($Class in $MECMClass)
		{
		$ActiveMonitors = @(Get-SCOMClassInstance -Class $Class | ? { ($_.healthstate -ne 'Success') -AND ( $_.healthstate -ne 'Uninitialized') -AND ($_.IsAvailable -eq $true) } )
		# Debug
		$ActiveMonitors.Count
		# $ActiveMonitors | fl -property *
		write-host "Found" $ActiveMonitors.Count "unhealthy monitors for class" $Class
		foreach ( $UnhealthyOLDMonitor in $ActiveMonitors )
			{
			#if ( $UnhealthyOLDMonitor.AvailabilityLastModified -lt $Age )
			if ( $UnhealthyOLDMonitor.StateLastModified -lt $Age )
				{
				#$UnhealthyMonitors += $ActiveMonitors.Count
				#UnhealthyOLDMonitor | select AvailabilityLastModified,Path,DisplayName
				#$UnhealthyOLDMonitor.Count
				#write-host "Found" + $UnhealthyOLDMonitor.Count + "unhealthy monitor beyond" $Age "days."
				#write-host ""
				if ( $ActiveMonitors.Count -gt 0)
					{
					foreach ( $ActiveMonitor in $UnhealthyOLDMonitor )
						{
						# Debug
						$ActiveMonitor.ID
						write-host " Resetting Health State on '" + $ActiveMonitor.FullName + "'" 
						write-host ""
						$ActiveMonitor.ResetMonitoringState($ActiveMonitor)
						}
					}
				}
			}
		}
	# Debug
	#$MonitorClass | fl -property *
	#$MonitorClass | select DisplayName,ID
	}


#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>

      <WriteActionModuleType ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.WA.v1029.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  SCCM MECM Client cache cleanup and C: drive cleanup
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================
param([string]$DriveLetter,[string]$ComputerName)


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ComputerName = "computername.domain.com"
#$DriveLetter = "C"
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
$ScriptName = "Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.Datasource.v1029.ps1"
$EventID = "680"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
# Load PropertyBag function 
$bag = $momapi.CreatePropertyBag()

#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# Begin MAIN script section
#=================================================================================
#Log script parameters we received
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script parameters passed into datasource: `nDriveLetter: ($DriveLetter). `nComputerName: ($ComputerName).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alert report for date ($date).")

$DSMessage = "Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for date ($date)."


# Check Disk free space
#=====================
$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -eq "C:" }
$CFreeSpace.DeviceID
 
    $DiskFreeSpace = [pscustomobject]@{
	DeviceID = $CFreeSpace.DeviceID
	Size = [math]::Round($CFreeSpace.Size/1GB,2)
	FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }
 
$DiskFreeSpace
 
$SoftwareDistribution = (gci C:\windows\SoftwareDistribution | measure length -s).sum / 1Mb
# Debug
$SoftwareDistribution 
 

# Check disk space (default C:)
#======================================= 
If ($DiskFreeSpace.FreeSpace -gt 15 )
	{
	$strCondition = "Good"
	$end
	}

If ($DiskFreeSpace.FreeSpace -lt 15 )
	{
	#Set the condition = bad.  This represents your script finding something wrong
	$strCondition = "Bad"

	# MECM SCCM Client Cleanup
	$resman= New-Object -ComObject "UIResource.UIResourceMgr"
	$cacheInfo=$resman.GetCacheInfo()
	$cacheinfo.GetCacheElements()  | foreach {$cacheInfo.DeleteCacheElement($_.CacheElementID)}

	# get-volume
	#=====================
	# $DriveLetter = "C"
	$ExpandC = get-volume
	$ExpandAction = $ExpandC | ? { ( $_.SizeRemaining -gt "0" ) -AND ( $_.Driveletter -eq "$DriveLetter" ) }

	if ( $ExpandAction.DriveLetter -eq $true)
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Expand drive via Disk Manager on ($ComputerName)")
		}

	# Cleanup C:\Windows\Temp
	#=====================
	# May see access denied errors - Get-ChildItem
	Get-ChildItem C:\Windows\Temp\ -Recurse | Remove-Item -Recurse -Force

	$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse | Measure-Object -Property Length -Sum ).sum


	# Check Disk free space AFTER cleanup
	#==================================
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID
 
	$DiskFreeSpace = [pscustomobject]@{
		DeviceID = $CFreeSpace.DeviceID
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
        }
 
	$DiskFreeSpace
 
	$DriveLetter = $CFreeSpace.DeviceID
 
 
	# Check for large profile sizes
	#==================================
	$Profiles=Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") -and ($_.localpath -notlike "C:\WINDOWS*"))}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }
	#$Profiles=Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") )}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }

	$ProfileTableObject = @()
 
	# Loop through profiles
	#foreach ($Profile in $Profiles)
		#{
		#$Profile
		#$Size = (gci $DriveLetter\users\$Profile -recurse| measure length -s).sum
		$Size = (gci $DriveLetter\users -recurse| measure length -s).sum
	 
		$ProfileTableObject += [pscustomobject]@{
		#AccountID = $Profile
		UserDirectory = "C:\Users"
		SizeGB = [math]::Round($Size/1GB,2)
	      }
	#}
	$ProfileTableObject
 
 
	# Check C Drive folder size
	#==========================
	#$CheckCDriveFolders = (gci C:\).Name | ? { ( $_ -ne "Users" ) -AND ( $_ -ne "Windows" )  }
	$CheckCDriveFolders = (gci $DriveLetter\).Name | ? { ( $_ -ne "Users" ) }
	$CheckCDriveFolders
 
	$Cfolders = @()
 
	Foreach ( $folder in $CheckCDriveFolders )
		{
		#$folder
		$Size = (Get-ChildItem "$DriveLetter\$folder" -Recurse | Measure-Object -Property Length -Sum ).sum
		#$Size
		$CFolders += [pscustomobject]@{
			Directory = $folder
			SizeGB = [math]::Round($Size/1GB,2)
			}
		}
	$Cfolders
	}


# Second attempt will clean up software distribution
#==================================
If ($DiskFreeSpace.FreeSpace -lt 15 )
	{
	# Audit Software Distribution
	#==================================
	If ( $SoftwareDistribution -lt "3000" )
		{
		Write-host "NO MECM\SCCM Action required"
		}

	If ( $SoftwareDistribution -gt "3000" )
		{
		Write-host "MECM\SCCM Action required, stopping Windows Update service, removing SoftwareDIstribution folder and restarting"
		Get-Service -Name wuauserv | Stop-Service 
		Remove-Item -Path C:\Windows\SoftwareDistribution -Recurse 
		Get-Service -Name wuauserv | Start-Service
		Write-host "Windows Update wuauserv service restarted after SoftwareDistribution directory removed"
		}


	# Summary Report
	#==================================
	$ProfileTableOutput = $ProfileTableObject | sort -property SizeGB -desc | out-string
	$CFolderOutput = $Cfolders | sort -property SizeGB -desc | out-string
 
	$SCCMClientCacheReport = @()
 
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += $DSMessage
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "MECM/SCCM Client Cache cleaned on server"
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "#===================================="
	$SCCMClientCacheReport += "# Drive audit of server for $date"
	$SCCMClientCacheReport += $DiskFreeSpace
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "# Software Distribution folder size"
	$SCCMClientCacheReport += $SoftwareDistribution
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "# Audit of profiles for cleanup"
	$SCCMClientCacheReport += $ProfileTableOutput
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "# Audit of folder size"
	$SCCMClientCacheReport += $CFolderOutput
	$SCCMClientCacheReport += ""
	$SCCMClientCacheReport += "NOTE: Manual effort required:"
	$SCCMClientCacheReport += "SysAdmin/Server SME required to clean up drive folders"
	$SCCMClientCacheReport += "#===================================="
	$SCCMClientCacheReport += ""
	}

$SCCMClientCacheReport

$SCCMClientCacheReport = $SCCMClientCacheReport | out-string



#Check the value of $strCondition
IF ($strCondition -eq "Good")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"NO MECM SCCM Team action required")
	$bag.AddValue('Result',$strCondition)
	}
IF ($strCondition -eq "Bad")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$SCCMClientCacheReport")
	$bag.AddValue('Result',$strCondition)
	$bag.AddValue('Summary',$SCCMClientCacheReport)
	}

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Reports.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Reports.WA.v1029.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather MECM cache cleanup alerts for team daily report
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Reports.WA.v1029.ps1"
$EventID = "681"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive MECM Client Cache Cleanup Alerts for date ($date).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-1)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}


# Gather MECM alerts
# Monitors then rules
$MECMClientCacheAlerts = get-scomalert | ? { ( $_.Name -like "Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for date*" ) `
	-OR ( $_.Name -like "Expand drive via Disk Manager on*" ) `
	}  | ? { ( $_.TimeRaised -ge $Time ) }


#$MECMReportAlerts
#$MECMClientCacheAlerts.Count

# Open MECM server alerts
$MECMOpenAlerts = $MECMClientCacheAlerts	| ? { ( $_.ResolutionState -ne "255" ) }
#$MECMOpenAlerts.Count

# Closed MECM server alerts
$MECMClosedAlerts = $MECMClientCacheAlerts | ? { ( $_.ResolutionState -eq "255" ) }
#$MECMClosedAlerts.Count


# Client Cache cleanup alerts
$MECMCacheCleanupAlerts = $MECMClientCacheAlerts | ? { ( $_.Name -like "Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for date*" ) }
#$MECMCacheCleanupAlerts.Count

# Open alerts
$OpenMECMCacheCleanupAlerts = $MECMCacheCleanupAlerts | ? { ( $_.ResolutionState -ne "255" ) }
#$OpenMECMCacheCleanupAlerts.Count

# Closed alerts
$ClosedMECMCacheCleanupAlerts = $MECMCacheCleanupAlerts | ? { ( $_.ResolutionState -eq "255" ) }
#$ClosedMECMCacheCleanupAlerts.Count


# Expand drives via disk manager server alerts
$MECMExpandDriveAlerts = $MECMClientCacheAlerts | ? { ( $_.Name -like "Expand drive via Disk Manager on*" ) }
#$MECMExpandDriveAlerts.Count

# Open MECM server alerts
$OpenMECMExpandDriveAlerts = $MECMExpandDriveAlerts	| ? { ( $_.ResolutionState -ne "255" ) }
#$OpenMECMExpandDriveAlerts.Count

# Closed MECM server alerts
$ClosedMECMExpandDriveAlerts = $MECMExpandDriveAlerts | ? { ( $_.ResolutionState -eq "255" ) }
#$ClosedMECMExpandDriveAlerts.Count


# Build report
$MECMTeamReport = @()


# Check for alerts 
if ( $MECMClientCacheAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for Proactive MECM Client Cache Cleanup Alerts for ($date)"
	$MECMTeamReport += "ZERO alerts for Proactive MECM Client Cache Cleanup Alerts for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $MECMClientCacheAlerts.Count -gt 0 )
	{
	#
	# Create table output

	#
	# Show MECM alerts by Time Raised,NetBiosComputerName,Message
	#
	$MECMTeamReport += ""
	$MECMTeamReport += "# Proactive MECM Client Cache Cleanup Alerts for $($date)"
	$MECMTeamReport += "#"
	$MECMTeamReport += "#"
	$MECMTeamReport += "# NEW Alerts since last run = $($MECMClientCacheAlerts.Count)"
	$MECMTeamReport += ""
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += "# Open MECM Client Cache alerts = $($OpenMECMCacheCleanupAlerts.Count)"
	$MECMTeamReport += "# Open MECM Client Cache alerts = $($OpenMECMExpandDriveAlerts.Count)"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += ""
	$MECMTeamReport += ""
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += "# CLOSED MECM Client Cache alerts = $($ClosedMECMCacheCleanupAlerts.Count)"
	$MECMTeamReport += "# CLOSED MECM Expand Drive alerts = $($ClosedMECMExpandDriveAlerts.Count)"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += ""

	# Add logic for alert detail

	$MECMTeamReport += ""
	$MECMTeamReport += "# OPEN Alert details"
	$MECMTeamReport += "#==============================="
	$MECMTeamReport += ""

 	if ( $OpenMECMCacheCleanupAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO Open MECM Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for ($date)."
		$MECMTeamReport += ""
		}
		
	if ( $OpenMECMCacheCleanupAlerts.Count -gt 0 )
		{
		$MECMTeamReport += "#"
		$MECMTeamReport += "# Open MECM SCCM ConfigMgr Client Cache Cleanup Alert details"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $OpenMECMCacheCleanupAlerts | out-string
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += ""
		}


 	if ( $OpenMECMExpandDriveAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO Open MECM Proactive Expand drive via Disk Manager Alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenMECMExpandDriveAlerts.Count -gt 0 )
		{
		$MECMTeamReport += "#"
		$MECMTeamReport += "# Open Expand drive via Disk Manager Alert details"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $OpenMECMExpandDriveAlerts | out-string
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += ""
		}

	$MECMTeamReport += ""
	$MECMTeamReport += "# CLOSED Alert details"
	$MECMTeamReport += "#==============================="
	$MECMTeamReport += ""

 	if ( $ClosedMECMCacheCleanupAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO Closed MECM Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for ($date)."
		$MECMTeamReport += ""
		}
		
	if ( $ClosedMECMCacheCleanupAlerts.Count -gt 0 )
		{
		$MECMTeamReport += "#"
		$MECMTeamReport += "# Closed MECM SCCM ConfigMgr Client Cache Cleanup Alert details"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $ClosedMECMCacheCleanupAlerts | out-string
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += ""
		}


 	if ( $ClosedMECMExpandDriveAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO Closed MECM Proactive Expand drive via Disk Manager Alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenMECMExpandDriveAlerts.Count -gt 0 )
		{
		$MECMTeamReport += "#"
		$MECMTeamReport += "# Closed Expand drive via Disk Manager Alert details"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $ClosedMECMExpandDriveAlerts | out-string
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += ""
		}
	}

#$MECMTeamReport

$MECMTeamReport = $MECMTeamReport | out-string

#============================================================

$Result = "GOOD"
$Message = "Proactive MECM Client Cache Cleanup Alerts for ($date)"
$MECMTeamReport
$momapi.LogScriptEvent($ScriptName,$EventID,0,"$MECMTeamReport")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$MECMTeamReport)


# Return all bags
$bag

$ReportTime = Get-Date
$ScriptTime = ($ReportTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"MECM Cache Cleanup Report Completed. `n Script Runtime: ($ScriptTime) seconds.")


#
# If Cleanup needed, array of report monitors

$momapi.LogScriptEvent($ScriptName,$EventID,0,"MECM Client Cache monitor cleanup for ($date).")

$MECMReportMonitorsToClose = @()

$MECMReportMonitorsToClose += "Proactive MECM SCCM ConfigMgr Client Cache Cleanup Monitor"


# Reset open monitors
if ( $MECMOpenAlerts.Count -gt 0 )
	{
	foreach ( $MonitorDisplayName in $MECMReportMonitorsToClose )
		{
		$Monitors = @(Get-SCOMMonitor -displayname $MonitorDisplayName)

		# Set up monitor objects to reset
		foreach ($Monitor in $Monitors)
			{
			$MonitorClass = Get-SCOMClass -Id $Monitor.Target.Id
			$ActiveMonitors = Get-SCOMClassInstance -Class $MonitorClass | ? { ($_.healthstate -ne 'Success') -AND ( $_.healthstate -ne 'Uninitialized') -AND ($_.IsAvailable -eq $true) }
			# Debug
			$ActiveMonitors.Count
			# $ActiveMonitors | fl -property *
			#write-host "Found" + $ActiveMonitors.Count + "active monitors of " $Monitor
			foreach ( $UnhealthyOLDMonitor in $ActiveMonitors )
				{
				#if ( $UnhealthyOLDMonitor.AvailabilityLastModified -lt $Age )
				if ( $UnhealthyOLDMonitor.StateLastModified -lt $Age )
					{
					#$UnhealthyMonitors += $ActiveMonitors.Count
					#UnhealthyOLDMonitor | select AvailabilityLastModified,Path,DisplayName
					#$UnhealthyOLDMonitor.Count
					#write-host "Found" + $UnhealthyOLDMonitor.Count + "unhealthy monitor beyond" $Age "days."
					#write-host ""
					if ( $ActiveMonitors.Count -gt 0)
						{
						foreach ( $ActiveMonitor in $UnhealthyOLDMonitor )
							{
							# Debug
							$ActiveMonitor.ID
							write-host " Resetting Health State on '" + $ActiveMonitor.FullName + "'" 
							write-host ""
							$ActiveMonitor.ResetMonitoringState($ActiveMonitor)
							}
						}
					}
				}
			}
		}
	}

$momapi.LogScriptEvent($ScriptName,$EventID,0,"MECM Client Cache monitor cleanup for ($date).")

#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType ID="Proactive.Microsoft.SystemCenter.Configuration.Manager.Reports.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.Microsoft.SystemCenter.Configuration.Manager.Reports.WA.v1029.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather MECM alerts for team daily report
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.MECM.SCCM.Configuration.Manager.Reports.Datasource.v1029.ps1"
$EventID = "682"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"


# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather MECM Alerts for date ($date).")


# Gather MECM alerts
# Monitors then rules
$MECMReportAlerts = get-scomalert -ResolutionState (0..254) | ? { ( $_.Name -eq "Available Megabytes of Memory is too low" ) `
	-OR ( $_.Name -eq "Action Account Not Configured Correctly" ) `
	-OR ( $_.Name -like "Asset Intelligence*" ) `
	-OR ( $_.Name -eq "Certificate lifespan alert" ) `
	-OR ( $_.Name -eq "Component stopped alert" ) `
	-OR ( $_.Name -eq "Content distribution alert" ) `
	-OR ( $_.Name -like "DFS-R: *" ) `
	-OR ( $_.Name -like "DHCP*" ) `
	-OR ( $_.Name -eq "DHCP Service Stopped" ) `
	-OR ( $_.Name -eq "Distribution fails to access network alert" ) `
	-OR ( $_.Name -eq "DNS Client Service Stopped" ) `
	-OR ( $_.Name -eq "Event log is full" ) `
	-OR ( $_.Name -eq "Fail to access site system alert" ) `
	-OR ( $_.Name -eq "Fail to read Active Directory alert" ) `
	-OR ( $_.Name -eq "Fail to update Active Directory alert" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Failed to install application on client" ) `
	-OR ( $_.Name -eq "File Dispatch Manager Not Connecting to Site Server" ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -eq "Logical disk current queue length is too high" ) `
	-OR ( $_.Name -eq "Logical Disk Free Space is low" ) `
	-OR ( $_.Name -like "Logical disk transfer*" ) `
	-OR ( $_.Name -eq "Maintenance task failure alert" ) `
	-OR ( $_.Name -like "Management point*" ) `
	-OR ( $_.Name -eq "Max Concurrent API Reached alert" ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -eq "Microsoft Windows Server AD PasswordCheck Script Alert Rule" ) `
	-OR ( $_.Name -like "MSSQL*" ) `
	-OR ( $_.Name -eq "NTFS reported the logical disk is in error or corrupt." ) `
	-OR ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -like "PROACTIVE -*" ) `
	-OR ( $_.Name -eq "Run As Account Could Not Log On" ) `
	-OR ( $_.Name -like "Site Component*" ) `
	-OR ( $_.Name -eq "Site Roles" ) `
	-OR ( $_.Name -like "Site Server*" ) `
	-OR ( $_.Name -eq "SMSExec CPU Usage is Too High" ) `
	-OR ( $_.Name -eq "Software Update Point Not Available" ) `
	-OR ( $_.Name -eq "SQL Server Port Not Correct." ) `
	-OR ( $_.Name -eq "State Migration Point Not Available" ) `
	-OR ( $_.Name -eq "System Center Management Health Service Unloaded System Rule(s)") `
	-OR ( $_.Name -eq "System Center Management Health Service Unable to Process New Configuration" ) `
	-OR ( $_.Name -eq "System summary task failure alert" ) `
	-OR ( $_.Name -eq "TCP/IP NetBIOS Service Stopped" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "Windows Event Log Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Firewall Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Remote Management Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Server Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "WSUS Synchronization Failed" ) `
	}  | ? { ( $_.TimeRaised -ge $Time ) }


#$MECMReportAlerts
#$MECMReportAlerts.Count


# Break out alerts into MECM servers
$MECMServerAlerts = @()

$MECMServerAlerts = $MECMReportAlerts | ? { ( $_.NetBiosComputerName -like "*##MECMServerRegEX##*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*##MECMServerRegEX##*" ) `
	}

#$MECMServerAlerts.Count

# Open MECM server alerts
$MECMOpenAlerts = $MECMServerAlerts	| ? { ( $_.ResolutionState -ne "255" ) }
#$MECMOpenAlerts.Count

# Open MECM server alerts since last report
$MECMAlertsSinceReport = $MECMServerAlerts | ? { ( $_.TimeRaised -ge $Time ) }
#$MECMAlertsSinceReport.Count

# Closed MECM server alerts
$MECMClosedAlerts = get-scomalert -ResolutionState 255 | ? { ( $_.Name -eq "Available Megabytes of Memory is too low" ) `
	-OR ( $_.Name -eq "Action Account Not Configured Correctly" ) `
	-OR ( $_.Name -like "Asset Intelligence*" ) `
	-OR ( $_.Name -eq "Certificate lifespan alert" ) `
	-OR ( $_.Name -eq "Component stopped alert" ) `
	-OR ( $_.Name -eq "Content distribution alert" ) `
	-OR ( $_.Name -like "DFS-R: *" ) `
	-OR ( $_.Name -like "DHCP*" ) `
	-OR ( $_.Name -eq "DHCP Service Stopped" ) `
	-OR ( $_.Name -eq "Distribution fails to access network alert" ) `
	-OR ( $_.Name -eq "DNS Client Service Stopped" ) `
	-OR ( $_.Name -eq "Event log is full" ) `
	-OR ( $_.Name -eq "Fail to access site system alert" ) `
	-OR ( $_.Name -eq "Fail to read Active Directory alert" ) `
	-OR ( $_.Name -eq "Fail to update Active Directory alert" ) `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "Failed to install application on client" ) `
	-OR ( $_.Name -eq "File Dispatch Manager Not Connecting to Site Server" ) `
	-OR ( $_.Name -eq "Health Service Heartbeat Failure" ) `
	-OR ( $_.Name -eq "Logical disk current queue length is too high" ) `
	-OR ( $_.Name -eq "Logical Disk Free Space is low" ) `
	-OR ( $_.Name -like "Logical disk transfer*" ) `
	-OR ( $_.Name -eq "Maintenance task failure alert" ) `
	-OR ( $_.Name -like "Management point*" ) `
	-OR ( $_.Name -eq "Max Concurrent API Reached alert" ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -eq "Microsoft Windows Server AD PasswordCheck Script Alert Rule" ) `
	-OR ( $_.Name -like "MSSQL*" ) `
	-OR ( $_.Name -eq "NTFS reported the logical disk is in error or corrupt." ) `
	-OR ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -like "PROACTIVE -*" ) `
	-OR ( $_.Name -eq "Run As Account Could Not Log On" ) `
	-OR ( $_.Name -like "Site Component*" ) `
	-OR ( $_.Name -eq "Site Roles" ) `
	-OR ( $_.Name -like "Site Server*" ) `
	-OR ( $_.Name -eq "SMSExec CPU Usage is Too High" ) `
	-OR ( $_.Name -eq "Software Update Point Not Available" ) `
	-OR ( $_.Name -eq "SQL Server Port Not Correct." ) `
	-OR ( $_.Name -eq "State Migration Point Not Available" ) `
	-OR ( $_.Name -eq "System Center Management Health Service Unloaded System Rule(s)") `
	-OR ( $_.Name -eq "System Center Management Health Service Unable to Process New Configuration" ) `
	-OR ( $_.Name -eq "System summary task failure alert" ) `
	-OR ( $_.Name -eq "TCP/IP NetBIOS Service Stopped" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "Windows Event Log Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Firewall Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Remote Management Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Server Service Stopped" ) `
	-OR ( $_.Name -eq "Windows Storport Miniport Driver has timed out a request" ) `
	-OR ( $_.Name -eq "WSUS Synchronization Failed" ) `
	}
#$MECMClosedAlerts.Count


#
# MECM Specific config alerts
$MECMAppAlerts = $MECMServerAlerts | ? { ( $_.Name -eq "Component stopped alert" ) `
	-OR ( $_.Name -eq "Content distribution alert" ) `
	-OR ( $_.Name -eq "Distribution fails to access network alert" ) `
	-OR ( $_.Name -eq "Fail to read Active Directory alert" ) `
	-OR ( $_.Name -eq "Fail to update Active Directory alert" ) `
	-OR ( $_.Name -eq "File Dispatch Manager Not Connecting to Site Server" ) `
	-OR ( $_.Name -eq "Maintenance task failure alert" ) `
	-OR ( $_.Name -like "Management point*" ) `
	-OR ( $_.Name -eq "MSSQL on Windows: Filegroup is running out of space" ) `
	-OR ( $_.Name -eq "MSSQL on Windows: Database ROWS Data is Out of Space" ) `
	-OR ( $_.Name -like "Site server*" ) `
	-OR ( $_.Name -eq "SQL Server Port Not Correct." ) `
	-OR ( $_.Name -eq "WSUS Synchronization Failed" ) `
	}
	# | ? { $_.TimeRaised -gt $Time }

#$MECMAppAlerts.Count

$OpenMECMAppAlerts = $MECMAppAlerts
#$OpenMECMAppAlerts.Count

$ClosedMECMAppAlerts = $MECMClosedAlerts | ? { ( $_.Name -eq "Component stopped alert" ) `
	-OR ( $_.Name -eq "Content distribution alert" ) `
	-OR ( $_.Name -eq "Distribution fails to access network alert" ) `
	-OR ( $_.Name -eq "Fail to read Active Directory alert" ) `
	-OR ( $_.Name -eq "Fail to update Active Directory alert" ) `
	-OR ( $_.Name -eq "File Dispatch Manager Not Connecting to Site Server" ) `
	-OR ( $_.Name -eq "Maintenance task failure alert" ) `
	-OR ( $_.Name -like "Management point*" ) `
	-OR ( $_.Name -eq "MSSQL on Windows: Filegroup is running out of space" ) `
	-OR ( $_.Name -eq "MSSQL on Windows: Database ROWS Data is Out of Space" ) `
	-OR ( $_.Name -like "Site server*" ) `
	-OR ( $_.Name -eq "SQL Server Port Not Correct." ) `
	-OR ( $_.Name -eq "WSUS Synchronization Failed" ) `
	}
#$ClosedMECMAppAlerts.Count




#
# Additional insights
#
# PROACTIVE - Server restart pending detected
$PendingRestart = $MECMServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) `
	}
	#| ? { $_.TimeRaised -gt $Time }

#$PendingRestart.Count
$PendingRestart = $PendingRestart | ft NetbiosComputerName,TimeRaised -auto -wrap

$OpenPendingRestart = $PendingRestart
#$OpenPendingRestart.Count

$ClosedPendingRestart = $MECMClosedAlerts | ? { ( $_.Name -eq "PROACTIVE - Server restart pending detected" ) }
#$ClosedPendingRestart.Count


#
# PROACTIVE - Server NOT rebooted in past month
$NotRebooted = $MECMServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) `
	} | ? { $_.TimeRaised -gt $Time }

#$NotRebooted.Count
$NotRebooted = $NotRebooted | ft NetbiosComputerName,TimeRaised -auto -wrap

$OpenNotRebooted = $NotRebooted
#$OpenNotRebooted.Count

$ClosedNotRebooted = $MECMClosedAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT rebooted in past month" ) }
#$ClosedNotRebooted.Count


#
# PROACTIVE - Server NOT patched in past month
$NotPatched = $MECMServerAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) `
	} | ? { $_.TimeRaised -gt $Time }

#$NotPatched.Count
$NotPatched = $NotPatched | ft NetbiosComputerName,TimeRaised -auto -wrap

$OpenNotPatched = $NotPatched
#$OpenNotPatched.Count

$ClosedNotPatched = $MECMClosedAlerts | ? { ( $_.Name -eq "PROACTIVE - Server NOT patched in past month" ) }
#$ClosedNotPatched.Count


#
# Failed to install application on client
$FailedAppInstall = $MECMReportAlerts | ? { ( $_.Name -eq "Failed to install application on client" ) `
	} | ? { $_.TimeRaised -gt $Time }
	
#$FailedAppInstall.Count


#
# High CPU Memory alerts
$HighAlerts = $MECMServerAlerts | ? { ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) `
	-OR ( $_.Name -eq "SMSExec CPU Usage is Too High" ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -like "Logical disk transfer*" ) `
	} | ? { $_.TimeRaised -gt $Time }

#$HighAlerts.Count
#$HighAlerts = $HighAlerts | ft NetBiosComputerName,TimeRaised,Name -auto

$OpenHighAlerts = $HighAlerts
#$OpenHighAlerts.Count

$ClosedHighAlerts = $MECMClosedAlerts | ? { ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-OR ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-OR ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-OR ( $_.Name -eq "The LSASS process has exceeded the processor utilization threshold over multiple samples." ) `
	-OR ( $_.Name -eq "SMSExec CPU Usage is Too High" ) `
	-OR ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-OR ( $_.Name -like "Logical disk transfer*" ) `
	}
#$ClosedHighAlerts.Count


#
# Action Account alerts
$ActionAccountAlerts = $MECMServerAlerts | ? { ( $_.Name -eq "Action Account Not Configured Correctly" ) `
	-OR ( $_.Name -eq "Run As Account Could Not Log On" ) `
	} | ? { $_.TimeRaised -gt $Time }

#$ActionAccountAlerts.Count

$OpenActionAccountAlerts = $ActionAccountAlerts
#$OpenActionAccountAlerts.Count

$ClosedActionAccountAlerts = $MECMClosedAlerts | ? { ( $_.Name -eq  "Action Account Not Configured Correctly" ) `
	-OR ( $_.Name -eq "Run As Account Could Not Log On" ) `
	}
#$ClosedActionAccountAlerts.Count

#
# Test totals of alerts
$Test = $MECMServerAlerts.count + $FailedAppInstall.Count
#$Test



# 
# Unhealthy/Maintenance mode agents
#
# Gather Details section
# $Details = get-scomagent | ? { $_.HealthState -ne "Success" } |ft DisplayName| out-string
#$Details

$Class = (get-scomclass -Name "Microsoft.Windows.Computer" )
$instance = ( $Class | ? { $_.Name -like "Microsoft.Windows.Computer" }  |Get-SCOMClassInstance )
  
 $MM = ($Instance | ? { $_.InMaintenanceMode -eq "True" }).DisplayName `
	| ? { ( $_.DisplayName -like "*##MECMServerRegEX##*" ) `
	}
	#write-host "MM Maintenance mode Agents `n" ; $Unhealthy.InputObject
    $MaintM = $MM | sort | out-string


#  $UnHealthyAgents = ( get-scomagent | ? { $_.HealthState -ne "Success" } ).DisplayName `
$UnHealthyAgents = ( get-scomagent | ? { $_.HealthState -ne "Success" } ).DisplayName `
	| ? { ( $_.DisplayName -like "*##MECMServerRegEX##*" ) `
	}

if ( $MM.Count -gt 0 )
	{
	$CompareMM = compare-object -ReferenceObject $MM -DifferenceObject $UnhealthyAgents
	}


  #foreach ( $server in $UnHealthyAgents )
	#{
	#if ( ! $($MaintM | select-string $server) -eq $True )
		#{
		#write-host $server "is in Maintenance"
		#$Unhealthy += "$server"
		#}
	#}

  #$Unhealthy
  #$Details = $Unhealthy.InputObject


#$MECMReportAlerts
#$DownAgents = get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -eq "Health Service Heartbeat Failure") `
# If you want to know alerts for all Down, don't use $MECMReportAlerts (has $Time built in)
#  $DownAgents = $MECMReportAlerts | ? { ($_.Name -eq "Health Service Heartbeat Failure") `
$DownAgents = get-SCOMAlert | ? { ($_.Name -eq "Health Service Heartbeat Failure") `
	-OR ( $_.Name -eq "Failed to Connect to Computer" ) `
	-OR ( $_.Name -eq "System Center Management Health Service Unloaded System Rule(s)") `
	-OR ( $_.Name -eq "System Center Management Health Service Unable to Process New Configuration" ) `
	} | ? { ( $_.NetBiosComputerName -like "*##MECMServerRegEX##*" ) `
	-OR ( $_.MonitoringObjectDisplayName -like "*##MECMServerRegEX##*" ) `
	}


#$DownAgents
#$DownAgents.count


if ( $DownAgents.Count -gt 0 )
	{
    $CompareDown = compare-object -ReferenceObject $DownAgents -DifferenceObject $UnhealthyAgents
	# Format output of DownAgents
	$Down = $DownAgents | ft MonitoringObjectDisplayName,TimeRaised,Name -autosize | out-string
	#$Down
	}


if ( $DownAgents.Count -eq 0 )
	{
	$Compare = $MM.Count + $CompareMM.Count
    $CompareDown = "ZERO NOT monitored servers as of report run"
	}


# Compare Unhealthy agents
$Unhealthy = @()

if ( $UnHealthyAgents.Count -eq 0 )
	{
	$Unhealthy += ""
	$Unhealthy += "ZERO NOT healthy agents as of report run"
	}

if ( $UnHealthyAgents.Count -gt 0 )
	{
	$Unhealthy += ""
	$Unhealthy += $UnHealthyAgents | sort | out-string
	$Unhealthy += ""
	}

$Test = $DownAgents.Count +   $UnHealthyAgents.Count
#$Test


#===============================================
#
# Logical Disk free space alerts
#===============================================

$LDSTest = $MECMReportAlerts | ? { ( $_.Name -eq "Logical disk Free space is low" ) }

if ( $LDSTest.Count -gt 0 )
	{
	#$LDSTest

	# Gather details
	$LDSSummary = $LDSTest |ft NetbiosComputerName,MonitoringObjectName,Parameters -autosize | out-string
	# Gather Details section
	$LDSDetails = $LDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string

	#$LDSSummary
	#$LDSDetails

	$OpenLDSTest = $LDSTest
	#$OpenLDSTest.Count

	if ( $OpenLDSTest.Count -gt 0 )
		{
		# Summary
		$LDSOpenSummary = $LDSTest |ft NetbiosComputerName,MonitoringObjectName,Parameters -autosize | out-string
		# Gather Details
		$LDSOpenDetails = $LDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string
		}

	$ClosedLDSTest = $MECMClosedAlerts | ? { ( $_.Name -eq "Logical disk Free space is low" ) }
	#$ClosedLDSTest.Count

	if ( $ClosedLDSTest.Count -gt 0 )
		{
		# Summary
		$LDSClosedSummary = $ClosedLDSTest |ft NetbiosComputerName,MonitoringObjectName,Parameters -autosize | out-string
		# Gather Details section
		$LDSClosedDetails = $ClosedLDSTest | fl NetbiosComputerName,MonitoringObjectName,Parameters,Description | out-string
		}
	}


#===============================================
# Expiring certificates
# Certificates about to expire/expired
#===============================================

$Class = (get-scomclass -DisplayName "Certificate" )
$instance = ( $Class |Get-SCOMClassInstance )
$MECMPKIexpired = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	# PKI certs can have Certstore, but it's not always searchable/display capable
	#} | ? { $_.CertStore -like "Intermediate Certification*" `
	} | ? { ( $_.Path -like "*##MECMServerRegEX##*" ) `
	} # | ft Path,Values -auto -wrap  # DisplayName

#$MECMPKIexpired.count

$MECMPKIpersonal = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	} | ? { ( $_.CertStore -eq "Personal" ) `
	} | ? { ( $_.Path -like "*##MECMServerRegEX##*" ) `
	} # | ft Path,Values -auto -wrap  # DisplayName

#$MECMPKIpersonal.count

# Intermediate Cert Check
	# PKI certs can have Certstore, but it's not always searchable/display capable
	#} | ? { $_.CertStore -like "Intermediate Certification*" `

$MECMIntermediate = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	} | ? { $_.CertStore -like "Intermediate Certification*" `
	} | ? { ( $_.Path -like "*##MECMServerRegEX##*" ) `
	} # | ft Path,Values -auto -wrap  # DisplayName
	
#$MECMIntermediate.Count


$MECMRootCerts = $Instance | ? { ( $_.HealthState -ne "Success" ) -AND ( $_.HealthState -ne "Uninitialized" ) `
	} | ? { $_.CertStore -like "Root" `
	} | ? { ( $_.Path -like "*##MECMServerRegEX##*" ) `
	} # | ft Path,Values -auto -wrap  # DisplayName
	#$MECMRootCerts.Count


#
# Remaining alerts - not Proactive
$MECMRemaining = @()
$MECMRemaining = $MECMServerAlerts | ? { ( $_.Name -notlike "Proactive*" ) `
	-AND ( $_.Name -notlike "Certificate lifespan alert*" ) `
	-AND ( $_.Name -notlike "Logical disk transfer*" ) `
	-AND ( $_.Name -notlike "Logical disk Free space is low*" ) `
	-AND ( $_.Name -notlike "Management point*" ) `
	-AND ( $_.Name -eq "Memory Pages Per Second is too High." ) `
	-AND ( $_.Name -eq "MSSQL on Windows: Filegroup is running out of space" ) `
	-AND ( $_.Name -eq "MSSQL on Windows: Database ROWS Data is Out of Space" ) `
	-AND ( $_.Name -eq "Percentage of Committed Memory in Use is too high" ) `
	-AND ( $_.Name -eq "Site server HINV process backlog alert" ) `
	-AND ( $_.Name -eq "Site server HINV process backlog alert" ) `
	-AND ( $_.Name -eq "Site server auth ddm inbox backlog alert" ) `
	-AND ( $_.Name -eq "SMSExec CPU Usage is Too High" ) `
	-AND ( $_.Name -eq "SQL Server Port Not Correct." ) `
	-AND ( $_.Name -eq "Total CPU Utilization Percentage is too high" ) `
	-AND ( $_.Name -eq "VMware (High): Virtual Machine CPU Usage is High" ) `
	-AND ( $_.Name -eq "WSUS Synchronization Failed" ) `
	}

#$MECMRemaining

$MECMRemaining = $MECMRemaining | ft NetbiosComputerName,TimeRaised,Name -auto -wrap


# Build report
$MECMTeamReport = @()


# Check for alerts 
if ( $MECMServerAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for MECM Team Daily report for ($date)"
	$MECMTeamReport += "ZERO alerts for MECM Team Daily report for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $MECMServerAlerts.Count -gt 0 )
	{
	#
	# Create table output	

	#
	# Show MECM alerts by Time Raised,NetBiosComputerName,Message
	#
	$MECMTeamReport += ""
	$MECMTeamReport += "# MECM Team Daily report for $($date)"
	$MECMTeamReport += "#"
	$MECMTeamReport += "#"
	$MECMTeamReport += "# NEW Alerts since last run = $($MECMAlertsSinceReport.Count)"
	$MECMTeamReport += ""
	$MECMTeamReport += "# Total OPEN alerts"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += "# MECM alerts = $($MECMOpenAlerts.Count)"
	$MECMTeamReport += ""
	$MECMTeamReport += "# Server performance alerts = $($OpenHighAlerts.Count)"
	$MECMTeamReport += "# Logical Disk full alerts = $($OpenLDSTest.Count)"
	$MECMTeamReport += "# MECM Application alerts = $($OpenMECMAppAlerts.Count)"
	$MECMTeamReport += "# MECM patch failures = $($FailedInstallAlerts.Count)"
	$MECMTeamReport += "# Action Account logon failures = $($OpenActionAccountAlerts.Count)"
	$MECMTeamReport += ""
	$MECMTeamReport += "# PKI expired certificate alerts = $($MECMPKIexpired.Count)"
	$MECMTeamReport += "# PKI expired personal certificate alerts = $($MECMPKIpersonal.Count)"
	$MECMTeamReport += "# PKI Intermediate certificate alerts = $($MECMIntermediate.Count)"
	$MECMTeamReport += "# PKI Root certificate alerts = $($MECMRootCerts.Count)"
	$MECMTeamReport += ""
 	$MECMTeamReport += "# Servers Pending Restart = $($OpenPendingRestart.Count)"
 	$MECMTeamReport += "# Servers servers NOT rebooted= $($OpenNotRebooted.Count)"
 	$MECMTeamReport += "# Servers NOT patched = $($OpenNotPatched.Count)"
	$MECMTeamReport += ""
 	$MECMTeamReport += "# Total remaining alerts = $($MECMRemaining.Count)"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += ""
	$MECMTeamReport += "# Monitoring Health"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += "# Servers in Maintenance mode = $($MM.Count)"
	$MECMTeamReport += "# Unhealthy Agents = $($UnHealthyAgents.Count)"
	$MECMTeamReport += "# Down agents = $(($DownAgents.MonitoringObjectDisplayName).Count)"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += ""
	$MECMTeamReport += ""
	$MECMTeamReport += "# CLOSED alerts"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += "# Server performance alerts = $($ClosedHighAlerts.Count)"
	$MECMTeamReport += "# Logical Disk full alerts = $($ClosedLDSTest.Count)"
	$MECMTeamReport += "# MECM Application alerts = $($ClosedMECMAppAlerts.Count)"
	$MECMTeamReport += "# Action Account logon failures = $($ClosedActionAccountAlerts.Count)"
	$MECMTeamReport += "#========================================================"
 	$MECMTeamReport += "# Servers Pending Restart = $($ClosedPendingRestart.Count)"
 	$MECMTeamReport += "# Servers servers NOT rebooted = $($ClosedRebooted.Count)"
 	$MECMTeamReport += "# Servers NOT patched = $($ClosedNotPatched.Count)"
	$MECMTeamReport += "#========================================================"
	$MECMTeamReport += ""

	#$MECMServerAlerts = $MECMServerAlerts | ft NetbiosComputerName,TimeRaised,Name -auto -wrap
	#$MECMServerAlerts


	$MECMTeamReport += ""
	$MECMTeamReport += "# OPEN Alert details"
	$MECMTeamReport += "#==============================="
	$MECMTeamReport += ""


	# Add logic for agents monitored/down/maintenance mode
	if ( $Test -eq 0)
		{
		$MECMTeamReport += "ZERO MECM servers NOT monitored for ($date)."
		$MECMTeamReport += ""
		}
	
	if ( $Test -gt 0)
		{
		$MECMTeamReport += "# NOT monitored servers for ($date)."
		$MECMTeamReport += "#================================================"
		$MECMTeamReport += $Down
		$MECMTeamReport += ""
		
		if ( $MM.Count -eq 0)
			{
			$MECMTeamReport += "ZERO MECM servers in maintenance mode for ($date)."
			$MECMTeamReport += ""
			}

		if ( $MM.Count -gt 0)
			{
			$MECMTeamReport += ""
			$MECMTeamReport += "# Servers in Maintenance Mode MM"
			$MECMTeamReport += "#==============================="
			$MECMTeamReport += $MaintM
			$MECMTeamReport += ""
			$MECMTeamReport += ""
			}
		}


 	if ( $OpenLDSTest.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM Logical Disk free space alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenLDSTest.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# Summary of Daily Logical Disk free space alerts for ($date)"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += "#"
		$MECMTeamReport += "# Logical Disk Free Space alerts"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $LDSOpenSummary
		$MECMTeamReport += ""
		$MECMTeamReport += "# Alert details"
		$MECMTeamReport += "#=============================="
		$MECMTeamReport += $LDSOpenDetails | out-string
		$MECMTeamReport += ""
		}


 	if ( $OpenMECMAppAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM Application alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenMECMAppAlerts.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# MECM Application alert detail for ($date)"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $OpenMECMAppAlerts | ft NetbiosComputerName,Parameters,Name -auto | out-string
		$MECMTeamReport += ""
		}


	if ( $OpenHighAlerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM Performance alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenHighAlerts.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "#  MECM Performance alert detail"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $OpenHighAlerts |ft TimeRaised,NetBiosComputerName,Description -auto -wrap | out-string
		$MECMTeamReport += ""
		}


	if ( $MECMPKIexpired.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM PKI Certificates about to expire for ($date)."
		$MECMTeamReport += ""
		}

	if ( $MECMPKIexpired.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# Certificates about to expire/expired"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $MECMPKIexpired | ft Path,Values -auto -wrap | out-string
		$MECMTeamReport += ""
		}

	if ( $MECMIntermediate.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM PKI Intermediate Certificates alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $MECMIntermediate.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# MECM Intermediate Certificate alerts = $($SharePointIntermediate.Count)"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $MECMIntermediate | ft Path,Values -auto -wrap | out-string
		$MECMTeamReport += ""
		$MECMTeamReport += "***Execute MANUAL task to disable certs!"
		$MECMTeamReport += ""
		}


	if ( $MECMRootCerts.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM PKI Root Certificates alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $SharePointRootCerts.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# MECM Root Certificate alerts = $($SharePointIntermediate.Count)"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $MECMRootCerts | ft Path,Values -auto -wrap | out-string
		$MECMTeamReport += ""
		$MECMTeamReport += "***Execute MANUAL task to disable certs!"
		$MECMTeamReport += ""
		}

	if ( $MECMPKIpersonal.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM PKI Personal Certificate alerts for ($date)."
		$MECMTeamReport += ""
		}

	if ( $MECMPKIpersonal.Count -gt 0 )
		{
		$MECMTeamReport += ""
		$MECMTeamReport += "# MECM Personal Certificate alerts = $($MECMPKIpersonal.Count)"
		$MECMTeamReport += "#============================================================"
		$MECMTeamReport += $MECMPKIpersonal | ft Path,Values -auto -wrap | out-string
		$MECMTeamReport += ""
		$MECMTeamReport += "***Manual task to update server/application certs required"
		$MECMTeamReport += ""
		}


	if ( $MECMRemaining.count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM other MECM Operating System issues for ($date)."
		$MECMTeamReport += ""
		}

	if ( $MECMRemaining.count -gt 0 )
		{
		$MECMTeamReport += "# Other MECM application OR Operating System issues "
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += $MECMRemaining
		$MECMTeamReport += "#========================"
		$MECMTeamReport += ""
		}

	# Failed to install applications
	if ( $OpenFailedAppInstall.Count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM 'Failed to install' application errors for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenFailedAppInstall.Count -gt 0 )
		{
		$FailedAppInstall = $FailedAppInstall | ft NetbiosComputerName,TimeRaised,Description -auto -wrap | out-string
		$MECMTeamReport += "# MECM 'Failed to install application on client' alerts"
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += $FailedAppInstall
		$MECMTeamReport += "#========================"
		$MECMTeamReport += ""
		}

	if ( $OpenPendingRestart.count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM servers pending restart for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenPendingRestart.count -gt 0 )
		{
		$MECMTeamReport += "# MECM servers pending reboot for patches"
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += $OpenPendingRestart | ft NetbiosComputerName,TimeRaised -auto -wrap | out-string
		$MECMTeamReport += "#========================"
		$MECMTeamReport += ""
		}

	if ( $OpenNotRebooted.count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM servers NOT rebooted in past 35 days as of ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenNotRebooted.count -gt 0 )
		{
		$MECMTeamReport += "# MECM servers not rebooted (at least 35 days pass before alert)"
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += $OpenNotRebooted | ft NetbiosComputerName,TimeRaised -auto -wrap | out-string
		$MECMTeamReport += "#========================"
		$MECMTeamReport += ""
		}

	if ( $OpenNotPatched.count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM servers NOT patched in past 35 days as of ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenNotPatched.count -gt 0 )
		{
		$MECMTeamReport += "# MECM servers not patched (at least 35 days pass before alert)"
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += $OpenNotPatched | ft NetbiosComputerName,TimeRaised -auto -wrap | out-string
		$MECMTeamReport += "#============================================="
		}
	
	
	if ( $OpenActionAccountAlerts.count -eq 0 )
		{
		$MECMTeamReport += "ZERO MECM Action Account errors for ($date)."
		$MECMTeamReport += ""
		}

	if ( $OpenActionAccountAlerts.count -gt 0 )
		{
		$MECMTeamReport += "# MECM Action Account alert detail"
		$MECMTeamReport += "#============================================="
		$MECMTeamReport += "# OPEN Action Account logon failures = $($OpenActionAccountAlerts.Count)"
		$MECMTeamReport += ""
		$MECMTeamReport += "# OPEN Action Account logon failures"
		$MECMTeamReport += $OpenActionAccountAlerts | ft NetbiosComputerName,Parameters  -auto | out-string
		$MECMTeamReport += "#============================================="
		}

	$MECMTeamReport += ""
	}

#$MECMTeamReport

$MECMTeamReport = $MECMTeamReport | out-string

#============================================================

	$Result = "GOOD"
	$Message = "MECM Team Daily report for ($date)"
	$MECMTeamReport
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$MECMTeamReport")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$MECMTeamReport)


# Return all bags
$bag

$ReportTime = Get-Date
$ScriptTime = ($ReportTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")


#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType ID="Proactive.Microsoft.SystemCenter.Configuration.Manager.Cleanup.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.Microsoft.SystemCenter.Configuration.Manager.Cleanup.WA.v1029.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather MECM alert cleanup for team daily report
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.Microsoft.SystemCenter.Configuration.Manager.Cleanup.WA.v1029.ps1"
$EventID = "682"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-1)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Cleanup MECM Alerts for date ($date).")


# Cleanup MECM alerts
#===============================================
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
$SCOMCoreMP = Get-SCOMManagementPack -DisplayName "Microsoft System Center 2012 Configuration Manager Monitoring"
$SCOMCoreRules = $SCOMCoreMP.GetRules()
$SCOMCoreMonitors = $SCOMCoreMP.GetMonitors()

$SCOMCoreReportAlerts = Get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMCoreReportAlerts.Count

$SCOMCoreRuleAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -in $SCOMCoreRules.DisplayName) }
$SCOMCoreRuleAlerts.Count

$SCOMCoreMonitorAlerts = $SCOMCoreReportAlerts | ? { ($_.Name -in $SCOMCoreMonitors.DisplayName ) }
$SCOMCoreMonitorAlerts.Count

# Open/Closed breakout
$OpenMECMAlerts = $SCOMCoreReportAlerts
$OpenMECMAlerts.Count
$ClosedMECMAlerts = Get-SCOMAlert -ResolutionState 255 | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$ClosedMECMAlerts.Count

#============================================================

  $Result = "GOOD"
  $Message = "MECM Team Daily Cleanup for ($date)"
  $DSMessage = "Proactive DailyTasks MECM Team Cleanup Script Alert Rule"


# Build report
#============================================================
$MECMTeamCleanup = @()

# Check for alerts 
if ( $SCOMCoreReportAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for MECM Team Daily Cleanup for ($date)"
	$MECMTeamCleanup += "ZERO alerts for MECM Team Daily Cleanup for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"ZERO alerts for $Message")
	}


# $MECMReportMonitorsToClose or $ActiveMonitors ?
#==================================================
if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	#
	# Create table output

	#
	# Show MECM alerts by Time Raised,NetBiosComputerName,Message
	#
	$MECMTeamCleanup += ""
	$MECMTeamCleanup += $DSMessage
	$MECMTeamCleanup += "#"
	$MECMTeamCleanup += "# MECM Team Daily Cleanup for $($date)"
	$MECMTeamCleanup += "#"
	$MECMTeamCleanup += "Reset $($ActiveMonitors.Count) unhealthy monitors"
	$MECMTeamCleanup += "#"
	}

$MECMTeamCleanup


# Log event with report
$momapi.LogScriptEvent($ScriptName,$EventID,0,"$MECMTeamCleanup")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$SCOMCoreReportAlerts.Count)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$MECMTeamCleanup)


# Return all bags
$bag

$ReportTime = Get-Date
$ScriptTime = ($ReportTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")


# Debug Write event for rule closure
#=================================================================================
# $UnhealthyMonitors = $($UnhealthyMonitors | measure-object -sum).sum
#$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive MECM monitors auto-closed on ($date).")
# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks MECM monitor reset completed for ($date)")

$SCOMCoreRulesToClear = $SCOMCoreRuleAlerts | where { ( $_.TimeAdded -lt $Age ) }
# Convert Age back to days for alert properties logging
$Days = ((Get-date) - $Age).Days
if ( $SCOMCoreRulesToClear.Count -gt 0 )
	{
	$SCOMCoreRulesToClear | Resolve-SCOMAlert -Comment "Closing $Days day old alerts after report alert generated - MECM SCCM Addendum Automation DS"
	}

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"MECM SCCM addendum automation rule reset completed for ($date)")


#=================================================================================
# Reset Monitors Script base code modified
# Put ps1 in mgmtpacks folder
# https://sc.scomurr.com/scom-2012-monitor-reset-cleaning-up-the-environment/
#	Download
# https://gallery.technet.microsoft.com/SCOM-2012-Batch-reset-63a17534
	
#Alternate
#https://gallery.technet.microsoft.com/scriptcenter/Auto-reset-script-for-d8b775ca

# Changed up logic to sort unique classes in mgmnt pack families.
# Added Age variable for monitors thanks to Aris Somatis - $Age specified in top level variables
# Cycling through monitors made reset loop huge ~650 monitors when only ~50 classes
# New logic reduced runtime from 8 minutes to roughly 8 seconds
#=================================================================================

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks MECM Monitors reset started for ($date).")


if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	# Get MECM SCCM classes
		$MECMLibrary = Get-SCOMManagementPack -name "Microsoft.SystemCenter2012.ConfigurationManager.Library"
			#get-scomclass -ManagementPack $MECMLibrary
		$MECMMonitoring = $SCOMCoreMP
			#get-scomclass -ManagementPack $MECMMonitoring | fl DisplayName,Name,ID
		$MECMDiscovery = Get-SCOMManagementPack -DisplayName "Microsoft System Center 2012 Configuration Manager Discovery"
			#get-scomclass -ManagementPack $MECMDiscovery | fl DisplayName,Name,ID

	# MECM pack naming
	$MECMClasses = @(Get-SCOMClass -ManagementPack $MECMLibrary; Get-SCOMClass -ManagementPack $MECMDiscovery; )
	$MECMClass = $MECMClasses | sort -property Name -uniq
	# Debug
	$MECMClass.Count

	# Set up monitor objects to reset
	foreach ($Class in $MECMClass)
		{
		$ActiveMonitors = @(Get-SCOMClassInstance -Class $Class | ? { ($_.healthstate -ne 'Success') -AND ( $_.healthstate -ne 'Uninitialized') -AND ($_.IsAvailable -eq $true) } )
		# Debug
		$ActiveMonitors.Count
		# $ActiveMonitors | fl -property *
		write-host "Found" $ActiveMonitors.Count "unhealthy monitors for class" $Class
		foreach ( $UnhealthyOLDMonitor in $ActiveMonitors )
			{
			#if ( $UnhealthyOLDMonitor.AvailabilityLastModified -lt $Age )
			if ( $UnhealthyOLDMonitor.StateLastModified -lt $Age )
				{
				#$UnhealthyMonitors += $ActiveMonitors.Count
				#UnhealthyOLDMonitor | select AvailabilityLastModified,Path,DisplayName
				#$UnhealthyOLDMonitor.Count
				#write-host "Found" + $UnhealthyOLDMonitor.Count + "unhealthy monitor beyond" $Age "days."
				#write-host ""
				if ( $ActiveMonitors.Count -gt 0)
					{
					foreach ( $ActiveMonitor in $UnhealthyOLDMonitor )
						{
						# Debug
						$ActiveMonitor.ID
						write-host " Resetting Health State on '" + $ActiveMonitor.FullName + "'" 
						write-host ""
						$ActiveMonitor.ResetMonitoringState($ActiveMonitor)
						}
					}
				}
			}
		}
	# Debug
	#$MonitorClass | fl -property *
	#$MonitorClass | select DisplayName,ID
	}


#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
    </ModuleTypes>
    <MonitorTypes>
      <UnitMonitorType ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.MonitorType" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="GoodCondition" NoDetection="false" />
          <MonitorTypeState ID="BadCondition" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:string" name="DriveLetter" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
		  <xsd:element minOccurs="1" type="xsd:integer" name="MatchCount" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
		  <OverrideableParameter ID="DriveLetter" Selector="$Config/DriveLetter$" ParameterType="string" />
		  <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
		  <OverrideableParameter ID="MatchCount" Selector="$Config/MatchCount$" ParameterType="int" />		  
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DS" TypeID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.Datasource">
			  <DriveLetter>$Config/DriveLetter$</DriveLetter>
			  <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </DataSource>
            <ConditionDetection ID="GoodConditionFilter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='Result']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">GoodCondition</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="BadConditionFilter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='Result']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">BadCondition</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
			  <SuppressionSettings>
                <MatchCount>$Config/MatchCount$</MatchCount>
              </SuppressionSettings>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="GoodCondition">
              <Node ID="GoodConditionFilter">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="BadCondition">
              <Node ID="BadConditionFilter">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
          <OnDemandDetections>
            <OnDemandDetection MonitorTypeStateID="GoodCondition">
              <Node ID="GoodConditionFilter">
                <Node ID="DS" />
              </Node>
            </OnDemandDetection>
            <OnDemandDetection MonitorTypeStateID="BadCondition">
              <Node ID="BadConditionFilter">
                <Node ID="DS" />
              </Node>
            </OnDemandDetection>
          </OnDemandDetections>
        </MonitorImplementation>
      </UnitMonitorType>
    </MonitorTypes>
  </TypeDefinitions>
  <Monitoring>
    <Discoveries>
      <Discovery ID="Proactive.MECM.SCCM.ConfigMgr.Subscription.Components.Group.DiscoveryRule" Enabled="true" Target="Proactive.MECM.SCCM.ConfigMgr.Subscription.Components.Group" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities" />
        </DiscoveryTypes>
        <DataSource ID="GroupPopulationDataSource" TypeID="SC!Microsoft.SystemCenter.GroupPopulator">
          <RuleId>$MPElement$</RuleId>
          <GroupInstanceId>$MPElement[Name="Proactive.MECM.SCCM.ConfigMgr.Subscription.Components.Group"]$</GroupInstanceId>
          <MembershipRules>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWSL!Microsoft.Windows.Server.6.2.LogicalDisk"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
				</RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWSL!Microsoft.Windows.Server.6.2.Processor"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWS2R2D!Microsoft.Windows.Server.2012.R2.OperatingSystem"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWS6D!Microsoft.Windows.Server.10.0.LogicalDisk"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWS6D!Microsoft.Windows.Server.10.0.OperatingSystem"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWS6D!Microsoft.Windows.Server.10.0.Processor"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWIIS6!Microsoft.Windows.InternetInformationServices.10.0.ApplicationPool"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWIIS6!Microsoft.Windows.InternetInformationServices.10.0.ServerRole"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWIIS6!Microsoft.Windows.InternetInformationServices.10.0.WebServer"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWIIS6!Microsoft.Windows.InternetInformationServices.10.0.WebSite"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWIIS2!Microsoft.Windows.InternetInformationServices.6.2.ApplicationPool"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWIIS2!Microsoft.Windows.InternetInformationServices.6.2.ServerRole"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWIIS2!Microsoft.Windows.InternetInformationServices.6.2.WebServer"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWIIS2!Microsoft.Windows.InternetInformationServices.6.2.WebSite"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="SC!Microsoft.SystemCenter.HealthService"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServerNamingConvention##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
          </MembershipRules>
        </DataSource>
      </Discovery>
      <Discovery ID="Proactive.MECM.LogicalDisk.H.500GB.Group.DiscoveryRule" Enabled="true" Target="Proactive.MECM.LogicalDisk.H.500GB.Group" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities" />
        </DiscoveryTypes>
        <DataSource ID="GroupPopulationDataSource" TypeID="SC!Microsoft.SystemCenter.GroupPopulator">
          <RuleId>$MPElement$</RuleId>
          <GroupInstanceId>$MPElement[Name="Proactive.MECM.LogicalDisk.H.500GB.Group"]$</GroupInstanceId>
          <MembershipRules>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWSL!Microsoft.Windows.Server.6.2.LogicalDisk"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <And>
                  <Expression>
                    <RegExExpression>
                      <ValueExpression>
                        <HostProperty>
                          <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                          <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                        </HostProperty>
                      </ValueExpression>
                      <Operator>MatchesRegularExpression</Operator>
                      <Pattern>(?i)##MECMServerNameDiskSpecific##</Pattern>
                    </RegExExpression>
                  </Expression>
                  <Expression>
                    <RegExExpression>
                      <ValueExpression>
                        <Property>$MPElement[Name="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</Property>
                      </ValueExpression>
                      <Operator>MatchesRegularExpression</Operator>
                      <Pattern>(?i)H:</Pattern>
                    </RegExExpression>
                  </Expression>
                </And>
              </Expression>
            </MembershipRule>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="MWS6D!Microsoft.Windows.Server.10.0.LogicalDisk"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <And>
                  <Expression>
                    <RegExExpression>
                      <ValueExpression>
                        <HostProperty>
                          <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                          <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                        </HostProperty>
                      </ValueExpression>
                      <Operator>MatchesRegularExpression</Operator>
                      <Pattern>(?i)##MECMServerNameDiskSpecific##</Pattern>
                    </RegExExpression>
                  </Expression>
                  <Expression>
                    <RegExExpression>
                      <ValueExpression>
                        <Property>$MPElement[Name="Windows!Microsoft.Windows.LogicalDevice"]/DeviceID$</Property>
                      </ValueExpression>
                      <Operator>MatchesRegularExpression</Operator>
                      <Pattern>(?i)H:</Pattern>
                    </RegExExpression>
                  </Expression>
                </And>
              </Expression>
            </MembershipRule>
          </MembershipRules>
        </DataSource>
      </Discovery>
      <Discovery ID="Proactive.MECM.SCCM.ConfigMgr.Windows.Servers.Group.DiscoveryRule" Enabled="true" Target="Proactive.MECM.SCCM.ConfigMgr.Windows.Servers.Group" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities" />
        </DiscoveryTypes>
        <DataSource ID="GroupPopulationDataSource" TypeID="SC!Microsoft.SystemCenter.GroupPopulator">
          <RuleId>$MPElement$</RuleId>
          <GroupInstanceId>$MPElement[Name="Proactive.MECM.SCCM.ConfigMgr.Windows.Servers.Group"]$</GroupInstanceId>
          <MembershipRules>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Server.Computer"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMAllManagedClientServersNamingConventions##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
          </MembershipRules>
        </DataSource>
      </Discovery>
      <Discovery ID="Proactive.Microsoft.SystemCenter.Configuration.Manager.Group.Discovery" Enabled="true" Target="Proactive.Microsoft.SystemCenter.Configuration.Manager.Group" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities" />
        </DiscoveryTypes>
        <DataSource ID="GroupPopulationDataSource" TypeID="SC!Microsoft.SystemCenter.GroupPopulator">
          <RuleId>$MPElement$</RuleId>
          <GroupInstanceId>$MPElement[Name="Proactive.Microsoft.SystemCenter.Configuration.Manager.Group"]$</GroupInstanceId>
          <MembershipRules>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)##MECMServersNamingConventions##</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
          </MembershipRules>
        </DataSource>
      </Discovery>
    </Discoveries>
    <Rules>
      <Rule ID="Proactive.MECM.SCCM.ConfigMgr.Client.ExpandVolume.Alert.Rule" Enabled="true" Target="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.Client" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
         <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">680</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Expand drive via Disk Manager on </Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.MECM.SCCM.ConfigMgr.Client.ExpandVolume.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.MECM.SCCM.ConfigMgr.Client.CacheCleanup.Alert.Rule" Enabled="true" Target="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.Client" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
         <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">680</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts for date</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.MECM.SCCM.ConfigMgr.Client.CacheCleanup.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>

      <Rule ID="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.MECM.SCCM.Configuration.Manager.Cleanup.Datasource">
            <TimeoutSeconds>3000</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Count']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Message']$</AlertParameter2>
              <AlertParameter3>$Data/Property[@Name='Summary']$</AlertParameter3>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Message']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.MECMAlerts.Report.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.MECM.SCCM.Configuration.Manager.Reports.Datasource">
            <TimeoutSeconds>600</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.MECMAlerts.Report.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Count']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Message']$</AlertParameter2>
              <AlertParameter3>$Data/Property[@Name='Summary']$</AlertParameter3>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Message']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>

      <Rule ID="Proactive.DailyTasks.MECMAlerts.Report.Script.Task.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">682</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>MECM Team Daily report for </Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.MECMAlerts.Report.Script.Task.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule> 
      <Rule ID="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Task.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">682</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Proactive DailyTasks MECM Team Cleanup Script Task Alert Rule</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Task.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Report.Script.Task.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">681</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Proactive MECM Client Cache Cleanup Alerts task for </Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Report.Script.Task.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
    </Rules>
    <Tasks>
      <Task ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="120" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.WA">
          <TimeoutSeconds>300</TimeoutSeconds>
        </WriteAction>
      </Task>
      <Task ID="Proactive.DailyTasks.MECMAlerts.Report.Script.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="120" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.Microsoft.SystemCenter.Configuration.Manager.Reports.WA">
          <TimeoutSeconds>300</TimeoutSeconds>
        </WriteAction>
      </Task>
      <Task ID="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="120" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.Microsoft.SystemCenter.Configuration.Manager.Cleanup.WA">
          <TimeoutSeconds>3000</TimeoutSeconds>
        </WriteAction>
      </Task>
      <Task ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Report.Script.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="120" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Reports.WA">
          <TimeoutSeconds>300</TimeoutSeconds>
        </WriteAction>
      </Task>
    </Tasks>
   <Monitors>
      <UnitMonitor ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor" Accessibility="Public" Enabled="false" Target="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.Client" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.MonitorType" ConfirmDelivery="true">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.AlertMessage">
          <AlertOnState>Warning</AlertOnState>  <!-- Warning or Error should match OperationalStates below  -->
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>  <!-- Common options for AlertSeverity are MatchMonitorHealth, Information, Warning, Error -->
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='Summary']$</AlertParameter1> <!-- This is an example of passing property output from the script into the alert description -->
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="GoodCondition" MonitorTypeStateID="GoodCondition" HealthState="Success" />
          <OperationalState ID="BadCondition" MonitorTypeStateID="BadCondition" HealthState="Warning" />  <!-- HealthState = Warning or Error -->
        </OperationalStates>
        <Configuration>
		  <DriveLetter>C</DriveLetter>  <!-- Just an example of some string data to pass into the script -->
          <TimeoutSeconds>360</TimeoutSeconds>
		  <MatchCount>1</MatchCount>  <!-- This is the number of consecutive matches that must be met before the monitor will change state.  Also a good example of passing in Integer data. -->
        </Configuration>
      </UnitMonitor>
    </Monitors>
    <Overrides>
      <DiscoveryPropertyOverride ID="Override.Discovery.Microsoft.SystemCenter2012.ConfigurationManager.SiteSystem.Discovery" Context="Windows!Microsoft.Windows.Server.Computer" Enforced="false" Discovery="MSCCM12D!Microsoft.SystemCenter2012.ConfigurationManager.SiteSystem.Discovery" Property="Enabled">
        <Value>false</Value>
      </DiscoveryPropertyOverride>

      <MonitorConfigurationOverride ID="Override.ErrorMBytes.Microsoft.Windows.Server.6.2.Legacy.LogicalDisk.FreeSpace.Monitor" Context="Proactive.MECM.LogicalDisk.H.500GB.Group" ContextInstance="dba12dde-b775-63aa-c7da-801bead3b097" Enforced="false" Monitor="MWS2M!Microsoft.Windows.Server.6.2.Legacy.LogicalDisk.FreeSpace.Monitor" Parameter="NonSystemDriveErrorMBytesThreshold">
        <Value>25600</Value>
      </MonitorConfigurationOverride>
      <MonitorConfigurationOverride ID="Override.WarningMBytes.Microsoft.Windows.Server.6.2.Legacy.LogicalDisk.FreeSpace.Monitor" Context="Proactive.MECM.LogicalDisk.H.500GB.Group" ContextInstance="dba12dde-b775-63aa-c7da-801bead3b097" Enforced="false" Monitor="MWS2M!Microsoft.Windows.Server.6.2.Legacy.LogicalDisk.FreeSpace.Monitor" Parameter="NonSystemDriveWarningMBytesThreshold">
        <Value>51200</Value>
      </MonitorConfigurationOverride>
      <MonitorConfigurationOverride ID="Override.Threshold.Microsoft.SystemCenter2012.ConfigurationManager.Perf_Threshold_SMSExec_CPU_Usage_Monitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.StandaloneSiteServer" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.Perf_Threshold_SMSExec_CPU_Usage_Monitor" Parameter="Threshold">
        <Value>200</Value>
      </MonitorConfigurationOverride>

      <MonitorPropertyOverride ID="Override.Severity.Microsoft.SystemCenter2012.ConfigurationManager.ReplicationState" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ReplicationToPrimarySite" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.ReplicationState" Property="AlertSeverity">
        <Value>Warning</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.StateSystem.FailedToExecuteSummaryTask" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.StateSystem.FailedToExecuteSummaryTask" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.DatabaseNotificationMonitor.FailedToExecuteMaintenanceTaskInTime" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.DatabaseNotificationMonitor.FailedToExecuteMaintenanceTaskInTime" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.InboxManager.AvailabilityMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.InboxManager.AvailabilityMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.ComponentMonitor.AvailabilityMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.ComponentMonitor.AvailabilityMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.WsusSyncManager.AvailabilityMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.WsusSyncManager.AvailabilityMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.WakeOnLanManager.AvailabilityMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.WakeOnLanManager.AvailabilityMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.FileDispatchManager.AvailabilityMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.FileDispatchManager.AvailabilityMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.FileDispatchManager.CouldNotConnectSiteServer" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.FileDispatchManager.CouldNotConnectSiteServer" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.SiteSystemStatusSummarizer.AvailabilityMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.SiteSystemStatusSummarizer.AvailabilityMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.OutboxMonitor.AvailabilityMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.OutboxMonitor.AvailabilityMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.LanSender.FailedToConnectToRemoteSite" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.LanSender.FailedToConnectToRemoteSite" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.InboxMonitor.AvailabilityMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.InboxMonitor.AvailabilityMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.DistributionManager.FailedToConnectDP" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.DistributionManager.FailedToConnectDP" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.ComponentStatusSummarizer.AvailabilityMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.ComponentStatusSummarizer.AvailabilityMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.SiteComponentManager.CreateADObjectStatus" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.SiteComponentManager" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.SiteComponentManager.CreateADObjectStatus" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Site.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.SiteRole" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.SDK.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.SdkProvider" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.ComponentServer.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ComponentServer" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.SiteComponent.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.SiteComponentManager" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.ComponentAggregateMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.ComponentAggregateMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.StandAloneSiteServer.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.StandaloneSiteServer" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.SSRS.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.SrsReportingPoint" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.SiteComponentManager.AvailabilityMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.SiteComponentManager" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.SiteComponentManager.AvailabilityMonitor" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.PrimarySite.Microsoft.SystemCenter2012.ConfigurationManager.ReplicationState" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ReplicationToPrimarySite" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.ReplicationState" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.ReplicationState" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ReplicationToCentralSite" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.ReplicationState" Property="GenerateAlert">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Instance.Microsoft.SystemCenter2012.ConfigurationManager.SQLPort" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.SiteServer" ContextInstance="c744e323-eec9-7702-8380-cd1103b6b620" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.SQLPort" Property="Enabled">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Instance.Microsoft.SystemCenter2012.ConfigurationManager.PxeServicePoint.WDS.ServiceHealth" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.PxeServicePoint" ContextInstance="e91049f2-41fd-88a7-d3d2-47292798af0e" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.PxeServicePoint.WDS.ServiceHealth" Property="Enabled">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Microsoft.SystemCenter2012.ConfigurationManager.DistributionManager.FailedToConnectDP" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.ServerComponent" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.DistributionManager.FailedToConnectDP" Property="Enabled">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Microsoft.SystemCenter2012.ConfigurationManager.DistributionPointInstallationMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.DistributionSource" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.DistributionPointInstallationMonitor" Property="Enabled">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Severity.Microsoft.SystemCenter2012.ConfigurationManager.Monitoring.SoftwareUpdatePoint.SyncMonitor" Context="MSCCM12L!Microsoft.SystemCenter2012.ConfigurationManager.SiteServer" Enforced="false" Monitor="MSCCM12M!Microsoft.SystemCenter2012.ConfigurationManager.Monitoring.SoftwareUpdatePoint.SyncMonitor" Property="AlertSeverity">
        <Value>Warning</Value>
      </MonitorPropertyOverride>
    </Overrides>
  </Monitoring>
  <Presentation>
    <StringResources>
      <StringResource ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.AlertMessage" />
      <StringResource ID="Proactive.MECM.SCCM.ConfigMgr.Client.ExpandVolume.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.MECM.SCCM.ConfigMgr.Client.CacheCleanup.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.MECMAlerts.Report.Script.Alert.Rule.AlertMessage" />	  
      <StringResource ID="Proactive.DailyTasks.MECMAlerts.Report.Script.Task.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Task.Rule.AlertMessage" />
      <StringResource ID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Report.Script.Task.Alert.Rule.AlertMessage" />
    </StringResources>
  </Presentation>
  <LanguagePacks>
    <LanguagePack ID="ENU" IsDefault="false">
      <DisplayStrings>
        <DisplayString ElementID="Microsoft.System.Center.Configuration.Manager.Monitoring.Addendum">
          <Name>Microsoft System Center 2012 forward Configuration Manager Monitoring Addendum</Name>
          <Description>
v1.0.2.9   4 Jan 2024 Resolution State logic improvements for large environments
v1.0.2.8  27 Dec 2023 Whitespace audit, ResolutionState changes, performance changes to DS/WA
v1.0.2.6  30 Nov 2023 Removed debug detail from DS/WA which showed in Health Explorer pane
v1.0.2.5  18 Jul 2023 Updated reports to informational
v1.0.2.4  27 Jun 2023 Reports to Warning, GMT setting, Override sync
v1.0.2.3   8 Jun 2022 Updated Reports, group regex, ClientCacheCleanup Monitor and Datasource
v1.0.0.5  23 May 2022 Separated Cleanup from report, updated specifics
v1.0.0.4  28 Apr 2022 Updated with WA, Task
v1.0.0.0  12 Oct 2020 Customizing SCCM monitoring Addendum</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Subscription.Components.Group">
          <Name>Proactive MECM SCCM ConfigMgr Subscription Components</Name>
          <Description>Created 21 Jan 2021 - KWJ - per customer request for actual server issues</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Windows.Servers.Group">
          <Name>Proactive MECM SCCM ConfigMgr Windows Servers</Name>
          <Description>Used to filter out initial MECM SCCM ConfigMgr discovery</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.LogicalDisk.H.500GB.Group">
          <Name>Proactive MECM Logical Disk H 500 GB</Name>
          <Description>Created 16 June 2021 - KWJ - Update Logical Disk free space alerts for 500GB H SCCM machines per MECM team call 16 June 2021</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.SystemCenter.Configuration.Manager.Group">
          <Name>MECM Team Microsoft Windows Servers dynamic group</Name>
          <Description>Created 31 Mar 2021 to only enable discovery for MECM Team owned servers, not the enterprise.</Description>
        </DisplayString>
		
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Subscription.Components.Group.DiscoveryRule">
          <Name>Populate Proactive.MECM.SCCM ConfigMgr Subscription Components</Name>
          <Description>This discovery rule populates the group 'Proactive.MECM.SCCM ConfigMgr Subscription Components'</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Windows.Servers.Group.DiscoveryRule">
          <Name>Populate Proactive.MECM.SCCM ConfigMgr Windows Servers</Name>
          <Description>This discovery rule populates the group 'Proactive.MECM.SCCM ConfigMgr Windows Servers'</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.LogicalDisk.H.500GB.Group.DiscoveryRule">
          <Name>Populate Proactive.MECM.Logical Disk H 500 GB</Name>
          <Description>This discovery rule populates the group 'Proactive.MECM.Logical Disk H 500 GB'</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.SystemCenter.Configuration.Manager.Group.Discovery">
          <Name>Populate MECM Team Microsoft Windows Servers dynamic group</Name>
          <Description>This discovery rule populates the group 'MECM Team Microsoft Windows Servers'</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.Datasource">
          <Name>Proactive MECM SCCM ConfigMgr Client Cache Cleanup Monitor Datasource</Name>
          <Description>This datasource generates Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.Configuration.Manager.Reports.Datasource">
          <Name>Proactive DailyTasks MECM Team daily report DataSource</Name>
          <Description>This datasource generates MECM Team daily report PowerShell script DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.Configuration.Manager.Cleanup.Datasource">
          <Name>Proactive DailyTasks MECM Team daily cleanup DataSource</Name>
          <Description>This datasource generates MECM Team daily report PowerShell script DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Reports.Datasource">
          <Name>Proactive MECM SCCM ConfigMgr Client Cache cleanup report DataSource</Name>
          <Description>This datasource generates MECM SCCM ConfigMgr Client Cache cleanup report PowerShell script DataSource</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.WA">
          <Name>Proactive MECM Client cache cleanup script (WA) write action on-demand task</Name>
          <Description>This write-action task generates MECM Client cache cleanup script (WA) write action</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.SystemCenter.Configuration.Manager.Reports.WA">
          <Name>Proactive DailyTasks MECM Team daily Reports on-demand task</Name>
          <Description>This write-action task generates MECM Team daily report PowerShell script (WA) write action</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.SystemCenter.Configuration.Manager.Cleanup.WA">
          <Name>Proactive DailyTasks MECM Team daily cleanup on-demand task</Name>
          <Description>This write-action task generates MECM Team daily report PowerShell script (WA) write action</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Reports.WA">
          <Name>Proactive MECM SCCM ConfigMgr Client Cache cleanup report on-demand task</Name>
          <Description>This write-action task generates MECM SCCM ConfigMgr Client Cache cleanup report PowerShell script (WA) write action</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.MonitorType">	
          <Name>Proactive MECM SCCM ConfigMgr Client Cache Cleanup MonitorType</Name>
          <Description>This MonitorType generates Proactive MECM SCCM ConfigMgr Client Cache Cleanup Alerts</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.Task">
          <Name>Proactive MECM Client cache cleanup script (WA) write action Task</Name>
          <Description>Proactive MECM Client cache cleanup script (WA) write action task to kick off on-demand</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Task">
          <Name>Proactive DailyTasks MECMAlerts Autoclose Cleanup Script Task</Name>
          <Description>Proactive DailyTasks MECMAlerts AutoClose task to kick off on-demand</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.MECMAlerts.Report.Script.Task">
          <Name>Proactive DailyTasks MECMAlerts Autoclose Report Script Task</Name>
          <Description>Proactive DailyTasks MECMAlerts AutoClose task to kick off on-demand</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Report.Script.Task">
          <Name>PProactive MECM SCCM ConfigMgr Client Cache cleanup Report Script Task</Name>
          <Description>Proactive MECM SCCM ConfigMgr Client Cache cleanup report task to kick off on-demand</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.ExpandVolume.Alert.Rule">
          <Name>Proactive MECM SCCM ConfigMgr Client ExpandVolume Alert Rule</Name>
          <Description>Proactive alert rule when volume can be expanded</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.ExpandVolume.Alert.Rule.AlertMessage">
          <Name>Proactive MECM SCCM ConfigMgr Client ExpandVolume Alert Rule</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.CacheCleanup.Alert.Rule">
          <Name>Proactive MECM SCCM ConfigMgr Client CacheCleanup Alert Rule</Name>
          <Description>Proactive alert rule when CacheCleanup automation required to clean up volume</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.CacheCleanup.Alert.Rule.AlertMessage">
          <Name>Proactive MECM SCCM ConfigMgr Client CacheCleanup Alert Rule</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Alert.Rule">
          <Name>Proactive DailyTasks MECM Team Cleanup Script Alert Rule</Name>
          <Description>Proactive Scheduled rule to kick off datasource at 0600 M-F</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks MECM Team Cleanup Script Alert Rule</Name>
          <Description>{1}

{2}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.MECMAlerts.Report.Script.Alert.Rule">
          <Name>Proactive DailyTasks MECM Team Cleanup Script Alert Rule</Name>
          <Description>Proactive Scheduled rule to kick off datasource at 0600 M-F</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.MECMAlerts.Report.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks MECM Team Report Script Alert Rule</Name>
          <Description>{1}

{2}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.MECMAlerts.Report.Script.Task.Alert.Rule">
          <Name>Proactive DailyTasks MECMAlerts task Report Manual Task Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.MECMAlerts.Report.Script.Task.Rule.AlertMessage">
          <Name>Proactive DailyTasks MECM Team Report Script Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Report.Script.Task.Alert.Rule">
          <Name>Proactive MECM SCCM ConfigMgr Client Cache Cleanup Script Task Report Manual Task Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Report.Script.Task.Alert.Rule.AlertMessage">
          <Name>Proactive MECM SCCM ConfigMgr Client Cache Cleanup Script Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Task.Rule">
          <Name>Proactive MECM SCCM ConfigMgr Client Cache Cleanup Manual Task Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.MECMAlerts.Cleanup.Script.Task.Rule.AlertMessage">
          <Name>Proactive MECM SCCM ConfigMgr Client Cache Cleanup Manual Script Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor">
          <Name>Proactive MECM SCCM ConfigMgr Client Cache Cleanup Monitor</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor" SubElementID="GoodCondition">
          <Name>Good Condition</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor" SubElementID="BadCondition">
          <Name>Bad Condition</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.MECM.SCCM.ConfigMgr.Client.Cache.Cleanup.Monitor.AlertMessage">
          <Name>Proactive MECM SCCM ConfigMgr Client Cache Cleanup Monitor: Failure</Name>
          <Description>Proactive MECM SCCM ConfigMgr Client Cache Cleanup Monitor
		  {1}</Description>
        </DisplayString>

        <DisplayString ElementID="Override.Severity.Microsoft.SystemCenter2012.ConfigurationManager.ReplicationState">
          <Name>NotUsed</Name>
          <Description>12 Oct 2020 - KWJ - Changing severity on replication issues</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.StateSystem.FailedToExecuteSummaryTask">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.DatabaseNotificationMonitor.FailedToExecuteMaintenanceTaskInTime">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.InboxManager.AvailabilityMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.ComponentMonitor.AvailabilityMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.WsusSyncManager.AvailabilityMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.WakeOnLanManager.AvailabilityMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.FileDispatchManager.AvailabilityMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.FileDispatchManager.CouldNotConnectSiteServer">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.SiteSystemStatusSummarizer.AvailabilityMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.OutboxMonitor.AvailabilityMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.LanSender.FailedToConnectToRemoteSite">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.InboxMonitor.AvailabilityMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.DistributionManager.FailedToConnectDP">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.ComponentStatusSummarizer.AvailabilityMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.SiteComponentManager.CreateADObjectStatus">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Site.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.SDK.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.ComponentServer.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.SiteComponent.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.ComponentAggregateMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.StandAloneSiteServer.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.SSRS.Microsoft.SystemCenter2012.ConfigurationManager.RoleAggregateMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.SiteComponentManager.AvailabilityMonitor">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.PrimarySite.Microsoft.SystemCenter2012.ConfigurationManager.ReplicationState">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Alert.Microsoft.SystemCenter2012.ConfigurationManager.ReplicationState">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling ConfigMgr roles per MEC team</Description>
        </DisplayString>
        <DisplayString ElementID="Override.ErrorMBytes.Microsoft.Windows.Server.6.2.Legacy.LogicalDisk.FreeSpace.Monitor">
          <Name>NotUsed</Name>
          <Description>16 June 2021 - KWJ - Updating per MECM team request</Description>
        </DisplayString>
        <DisplayString ElementID="Override.WarningMBytes.Microsoft.Windows.Server.6.2.Legacy.LogicalDisk.FreeSpace.Monitor">
          <Name>NotUsed</Name>
          <Description>16 June 2021 - KWJ - Updating per MECM team request</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Threshold.Microsoft.SystemCenter2012.ConfigurationManager.Perf_Threshold_SMSExec_CPU_Usage_Monitor">
          <Name>NotUsed</Name>
          <Description>13 Aug 2021 - KWJ - Increasing value to 200 as SCCM servers have 4-16 cores (per Pat McCoy MECM Admin)</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Instance.Microsoft.SystemCenter2012.ConfigurationManager.SQLPort">
          <Name>NotUsed</Name>
          <Description>26 Jan 2022 - KWJ - Disabling alert after verified false positive</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Instance.Microsoft.SystemCenter2012.ConfigurationManager.PxeServicePoint.WDS.ServiceHealth">
          <Name>NotUsed</Name>
          <Description>23 Feb 2022 - KWJ - Disabling per MECM Team WOC Corcoran</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.SystemCenter2012.ConfigurationManager.DistributionManager.FailedToConnectDP">
          <Name>NotUsed</Name>
          <Description>24 Feb 2022 - KWJ - Disabling per MECM team lead WOC Corcoran</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.SystemCenter2012.ConfigurationManager.DistributionPointInstallationMonitor">
          <Name>NotUsed</Name>
          <Description>24 Feb 2022 - KWJ - Disable per MECM lead WOC Corcoran</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Discovery.Microsoft.SystemCenter2012.ConfigurationManager.SiteSystem.Discovery">
          <Name>NotUsed</Name>
          <Description>22 Mar 2022 - KWJ - Disable Discovery for all assets</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Severity.Microsoft.SystemCenter2012.ConfigurationManager.Monitoring.SoftwareUpdatePoint.SyncMonitor">
          <Name>NotUsed</Name>
          <Description>27 Jun 2023 - KWJ - Override Severity to Warning</Description>
        </DisplayString>
      </DisplayStrings>
    </LanguagePack>
  </LanguagePacks>
</ManagementPack>